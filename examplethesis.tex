
%%
%% forked from https://gits-15.sys.kth.se/giampi/kthlatex kthlatex-0.2rc4 on 2020-02-13
%% expanded upon by Gerald Q. Maguire Jr.
%% This template has been adapted by Anders Sjögren to the University
%% Engineering Program in Computer Science at KTH ICT. This adaptation was to
%% translation of English headings into Swedish as the addition of Swedish.
%% Many thanks to others who have provided constructive input regarding the template.

% Make it possible to conditionally depend on the TeX engine used
\RequirePackage{ifxetex}
\RequirePackage{ifluatex}
\newif\ifxeorlua
\ifxetex\xeorluatrue\fi
\ifluatex\xeorluatrue\fi

\ifxeorlua
% The following is to ensure that the PDF uses a recent version rather than the typical PDF 1-5
%  This same version of PDF should be set as an option for hyperef

\RequirePackage{expl3}
\ExplSyntaxOn
%pdf_version_gset:n{2.0}
%\pdf_version_gset:n{1.5}

%\DocumentMetadata
%{
%% testphase = phase-I, % tagging without paragraph tagging
%% testphase = phase-II % tagging with paragraph tagging and other new stuff.
%pdfversion = 2.0 % pdfversion must be set here.
%}

% Optionally, you can set the uncompress flag to make it easier to examine the PDF
%\pdf_uncompress: % to check the pdf
\ExplSyntaxOff
\else
\RequirePackage{expl3}
\ExplSyntaxOn
%\pdf_version_gset:n{2.0}
\pdf_version_gset:n{1.5}
\ExplSyntaxOff
\fi


%% The template is designed to handle a thesis in English or Swedish
% set the default language to english or swedish by passing an option to the documentclass - this handles the inside tile page
% To optimize for digital output (this changes the color palette add the option: digitaloutput
% To use \ifnomenclature add the option nomenclature
% To use bibtex or biblatex - include one of these as an option
\documentclass[nomenclature, english, bibtex]{kththesis}
%\documentclass[swedish, biblatex]{kththesis}
% if pdflatex \usepackage[utf8]{inputenc}

%% Conventions for todo notes:
% Informational
%% \generalExpl{Comments/directions/... in English}
\newcommand*{\generalExpl}[1]{\todo[inline]{#1}}                

% Language-specific information (currently in English or Swedish)
\newcommand*{\engExpl}[1]{\todo[inline, backgroundcolor=kth-lightgreen40]{#1}} %% \engExpl{English descriptions about formatting}
\newcommand*{\sweExpl}[1]{\todo[inline, backgroundcolor=kth-lightblue40]{#1}}  %% % \sweExpl{Text på svenska}
\newcommand{\inlinecode}[1]{\texttt{#1}}

% warnings
\newcommand*{\warningExpl}[1]{\todo[inline, backgroundcolor=kth-lightred40]{#1}} %% \warningExpl{warnings}

% Uncomment to hide specific comments, to hide **all** ToDos add `final` to
% document class
% \renewcommand\warningExpl[1]{}
% \renewcommand\generalExpl[1]{}
% \renewcommand\engExpl[1]{}
% For example uncommenting the following line hides the Swedish language explanations
% \renewcommand\sweExpl[1]{}


% \usepackage[style=numeric,sorting=none,backend=biber]{biblatex}
\ifbiblatex
    %\usepackage[language=english,bibstyle=authoryear,citestyle=authoryear, maxbibnames=99]{biblatex}
    % alternatively you might use another style, such as IEEE and use citestyle=numeric-comp  to put multiple citations in a single pair of square brackets
    %\usepackage[style=ieee,citestyle=numeric-comp]{biblatex}
    \addbibresource{references.bib}
    %\DeclareLanguageMapping{norsk}{norwegian}
\else
    % The line(s) below are for BibTeX
    \bibliographystyle{bibstyle/myIEEEtran}
    %\bibliographystyle{apalike}
\fi


% include a variety of packages that are useful
\input{lib/includes}
\input{lib/kthcolors}

%\glsdisablehyper
%\makeglossaries
%\makenoidxglossaries
%\input{lib/acronyms}                %load the acronyms file

\input{lib/defines}  % load some additional definitions to make writing more consistent

% The following is needed in conjunction with generating the DiVA data with abstracts and keywords using the scontents package and a modified listings environment
%\usepackage{listings}   %  already included
\ExplSyntaxOn
\newcommand\typestoredx[2]{\expandafter\__scontents_typestored_internal:nn\expandafter{#1} {#2}}
\ExplSyntaxOff
\makeatletter
\let\verbatimsc\@undefined
\let\endverbatimsc\@undefined
\lst@AddToHook{Init}{\hyphenpenalty=50\relax}
\makeatother


\lstnewenvironment{verbatimsc}
    {
    \lstset{%
        basicstyle=\ttfamily\tiny,
        backgroundcolor=\color{white},
        %basicstyle=\tiny,
        %columns=fullflexible,
        columns=[l]fixed,
        language=[LaTeX]TeX,
        %numbers=left,
        %numberstyle=\tiny\color{gray},
        keywordstyle=\color{red},
        breaklines=true,                 % sets automatic line breaking
        breakatwhitespace=true,          % sets if automatic breaks should only happen at whitespace
        %keepspaces=false,
        breakindent=0em,
        %fancyvrb=true,
        frame=none,                     % turn off any box
        postbreak={}                    % turn off any hook arrow for continuation lines
    }
}{}

%% Add some more keywords to bring out the structure more
\lstdefinestyle{[LaTeX]TeX}{
morekeywords={begin, todo, textbf, textit, texttt}
}

%% definition of new command for bytefield package
\newcommand{\colorbitbox}[3]{%
	\rlap{\bitbox{#2}{\color{#1}\rule{\width}{\height}}}%
	\bitbox{#2}{#3}}




% define a left aligned table cell that is ragged right
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

% Because backref is not compatible with biblatex
\ifbiblatex
    \usepackage[plainpages=false]{hyperref}
\else
    \usepackage[
    backref=page,
    pagebackref=false,
    plainpages=false,
                            % PDF related options
    unicode=true,           % Unicode encoded PDF strings
    bookmarks=true,         % generate bookmarks in PDF files
    bookmarksopen=false,    % Do not automatically open the bookmarks in the PDF reading program
    pdfpagemode=UseNone,    % None, UseOutlines, UseThumbs, or FullScreen
    destlabel,              % better naming of destinations
    pdfencoding=auto,       % for unicode in 
    ]{hyperref}
    \makeatletter
    \ltx@ifpackageloaded{attachfile2}{
    % cannot use backref if one is using attachfile
    }
    {\usepackage{backref}
    %
    % Customize list of backreferences.
    % From https://tex.stackexchange.com/a/183735/1340
    \renewcommand*{\backref}[1]{}
    \renewcommand*{\backrefalt}[4]{%
    \ifcase #1%
          \or [Page~#2.]%
          \else [Pages~#2.]%
    \fi%
    }
    }
    \makeatother

\fi
\usepackage[all]{hypcap}	%% prevents an issue related to hyperref and caption linking

%% Acronyms
% note that nonumberlist - removes the cross references to the pages where the acronym appears
% note that super  sets the descriptions text aligned
% note that nomain - does not produce a main glossary, thus only acronyms is in the glossary
% note that nopostdot -  prevents there being a period at the end of each entry
\usepackage[acronym, style=super, section=section, nonumberlist, nomain,
nopostdot]{glossaries}
%\newglossarystyle{myglossary}{
%  \setglossarystyle{list} % Use the list style as a base
%  \renewcommand*{\glossaryentryfield}[5]{%
%    \item[\glsentryitem{##1}\glstarget{##1}{##2}] %
%    \hspace{1em} % Add some space between the name and description columns
%   \parbox[t]{\glsdescwidth}{##3} % Set the width of the description column
%    \space ##5 % Add the symbol
%    \glspostdescription % Add any post-description formatting
%    \space ##4 % Add the page number
%    \par
%  }
%}
\setlength{\glsdescwidth}{0.8\textwidth}
\usepackage[]{glossaries-extra}
\ifinswedish
    %\usepackage{glossaries-swedish}
\fi

%% For use with the README_notes
% Define a new type of glossary so that the acronyms defined in the README_notes document can be distinct from those in the thesis template
% the tlg, tld, and dn are the file extensions used for this glossary
\newglossary[tlg]{readme}{tld}{tdn}{README acronyms}

%% For use with the Aïssata's glossary
% Define a new type of glossary distinct from those in the thesis template
% the flg, fld, and fdn are the file extensions used for this glossary
\newglossary[flg]{fullg}{fld}{fdn}{Glossary}
\input{lib/includes-after-hyperref}

% For the intro glossary
\newglossary[ilg]{introductiongloss}{ild}{idn}{Introduction Glossary}

%\glsdisablehyper
\makeglossaries
%\makenoidxglossaries

% The following bit of ugliness is because of the problems PDFLaTeX has handling a non-breaking hyphen
% unless it is converted to UTF-8 encoding.
% If you do not use such characters in your acronyms, this could be simplified to just include the acronyms file.
\ifxeorlua
\input{lib/acronyms}    
\else
\input{lib/acronyms-for-pdflatex}
\fi

\input{lib/maingloss}
\input{lib/introductiongloss}  

% insert the configuration information with author(s), examiner, supervisor(s), ...
\input{custom_configuration}

\title{Does Rust SPARK joy?}
\subtitle{Recommendations for safe cross-language bindings between Rust and SPARK}

% give the alternative title - i.e., if the thesis is in English, then give a Swedish title
\alttitle{Does Rust SPARK joy?}
% You can just comment out the following line - if you do not have a Swedish subtitle
\altsubtitle{Detta är den svenska översättningen av undertiteln}
% alternative, if the thesis is in Swedish, then give an English title
%\alttitle{This is the English translation of the title}
%\altsubtitle{This is the English translation of the subtitle}

% Enter the English and Swedish keywords here for use in the PDF meta data _and_ for later use
% following the respective abstract.
% Try to put the words in the same order in both languages to facilitate matching. For example:
\EnglishKeywords{Rust, Ada, SPARK, Foreign Function Interface (FFI), memory safety, type safety, ownership}
\SwedishKeywords{Rust, Ada, SPARK, Gränssnitt för främmande funktioner (FFI), minnessäkerhet, typsäkerhet, ownership}

%%%%% For the oral presentation
%% Add this information once your examiner has scheduled your oral presentation
\presentationDateAndTimeISO{2022-03-15 13:00}
\presentationLanguage{eng}
\presentationRoom{via Zoom https://kth-se.zoom.us/j/ddddddddddd}
\presentationAddress{Isafjordsgatan 22 (Kistagången 16)}
\presentationCity{Stockholm}

% When there are multiple opponents, separate their names with '\&'
% Opponent's information
\opponentsNames{A. B. Normal \& A. X. E. Normalè}

% Once a thesis is approved by the examiner, add the TRITA number
% The TRITA number for a thesis consists of two parts a series (unique to each school)
% and the number in the series which is formatted as the year followed by a colon and
% then a unique series number for the thesis - starting with 1 each year.
\trita{TRITA-EECS-EX}{2023:0000}

% Put the title, author, and keyword information into the PDF meta information
\input{lib/pdf_related_includes}


% the custom colors and the commands are defined in defines.tex    
\hypersetup{
	colorlinks  = true,
	breaklinks  = true,
	linkcolor   = \linkscolor,
	urlcolor    = \urlscolor,
	citecolor   = \refscolor,
	anchorcolor = black
}

\ifnomenclature
% The following lines make the page numbers and equations hyperlinks in the Nomenclature list
\renewcommand*{\pagedeclaration}[1]{\unskip, \dotfill\hyperlink{page.#1}{page\nobreakspace#1}}
% The following does not work correctly, as the name of the cross-reference is incorrect
%\renewcommand*{\eqdeclaration}[1]{, see equation\nobreakspace(\hyperlink{equation.#1}{#1})}

% You can also change the page heading for the nomenclature
\renewcommand{\nomname}{List of Symbols Used}

% You can even add customization text before the list
\renewcommand{\nompreamble}{The following symbols are  later used within the body of the thesis.}
\makenomenclature
\fi

%
% The commands below are to configure JSON listings
% 
% format for JSON listings
\colorlet{punct}{red!60!black}
\definecolor{delim}{RGB}{20,105,176}
\definecolor{numb}{RGB}{106, 109, 32}
\definecolor{string}{RGB}{0, 0, 0}

\lstdefinelanguage{json}{
    numbers=none,
    numberstyle=\small,
    frame=none,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    extendedchars=false,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1}
      {’}{{\char13}}1,
}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\color{blue}\bfseries\small,
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{blue},
  keywordstyle=\color{cyan},
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
  breakatwhitespace=true,
  morekeywords={xmlns,version,type}% list your attributes here
}


% In case you use both listings and lstlistings - this makes them both use the same counter
\makeatletter
\AtBeginDocument{\let\c@listing\c@lstlisting}
\makeatother
\usepackage{subfiles}

% To have Creative Commons (CC) license and logos use the doclicense package
% Note that the lowercase version of the license has to be used in the modifier
% i.e., one of by, by-nc, by-nd, by-nc-nd, by-sa, by-nc-sa, zero.
% For background see:
% https://www.kb.se/samverkan-och-utveckling/oppen-tillgang-och-bibsamkonsortiet/open-access-and-bibsam-consortium/open-access/creative-commons-faq-for-researchers.html
% https://kib.ki.se/en/publish-analyse/publish-your-article-open-access/open-licence-your-publication-cc
\usepackage[
    type={CC},
    %modifier={by-nc-nd},
    %version={4.0},
    modifier={by-nc},
    imagemodifier={-eu-88x31},  % to get Euro symbol rather than Dollar sign
    hyphenation={RaggedRight},
    version={4.0},
    %modifier={zero},
    %version={1.0},
]{doclicense}


\begin{document}
%\selectlanguage{swedish}
%
\selectlanguage{english}

%%% Set the numbering for the title page to a numbering series not in the preface or body
\pagenumbering{alph}
\kthcover
\clearpage\thispagestyle{empty}\mbox{} % empty back of front cover
\titlepage

% If you do not want to have a bookinfo page, comment out the line saying \bookinfopage and add a \cleardoublepage
% If you want a bookinfo page: you get a copyright notice, unless you have used the doclicense package in which case you  get a Creative Commons license. To include the doclicense package, uncomment the configuration of this package above and configure it with your choice of license.
\bookinfopage

% Frontmatter includes the abstracts and table-of-contents
\frontmatter
\setcounter{page}{1}
\begin{abstract}
% The first abstract should be in the language of the thesis.
% Abstract fungerar på svenska också.
  \markboth{\abstractname}{}
\begin{scontents}[store-env=lang]
eng
\end{scontents}
%%% The contents of the abstract (between the begin and end of scontents) are saved in LaTeX format
%%% and output on the page(s) at the end of the thesis with information for DiVA facilitating the correct
%%% entry of the meta data for your thesis.
%%% These page(s) are removed before the thesis is inserted into DiVA.
%\engExpl{All theses at KTH are \textbf{required} to have an abstract in both \textit{English} and \textit{Swedish}.}

%\engExpl{Exchange students may want to include one or more abstracts in the language(s) used in their home institutions to avoid the need to write another thesis when returning to their home institution.}

%Write an abstract that is about 250 and 350 words (1/2 A4-page)  with the following components:
% key parts of the abstract


\begin{scontents}[store-env=abstracts,print-env=true]
%\generalExpl{Enter your abstract here!}

This thesis aims to provide recommendations for interfacing two memory-safe programming languages, Rust and SPARK. Such combinations have been extensively studied between Rust/SPARK and the unsafe C/C++, but not as extensively for memory-safe languages.

SPARK is a subset of Ada, a programming language with a long track record in safety-critical applications. Rust is a multi-paradigm language that has gained popularity since its emergence roughly a decade ago. Both languages implement ownership systems and type safety, instrumental in developing safe and reliable software.

Memory-safety bugs in code written in C/C++ account for about \SI{70}{\percent} of major vulnerabilities in the industry, as reported by organizations such as Microsoft, Apple, and Google. While tools to avoid memory errors exist, code cannot be made safe retroactively, which creates a need for languages designed with safety in mind, such as Rust and SPARK. 

Combining those two languages is a very promising path for low-level and systems programming, as well as safety-critical applications (automotive, avionics, medical \ldots). This thesis identifies best practices for safe bindings between Rust and SPARK, focusing on ensuring memory safety, type safety, and ownership, and then analyzes how to maintain or transfer those properties. The thesis provides clear recommendations based on control study programs and a real-world example using BBQueue, a circular buffer library suitable for embedded systems implemented in both languages. The identified best practices can be used for safe bindings and automated tools/code generation. 

This thesis fills a gap in existing research, primarily focusing on combining safe and unsafe languages. It provides a valuable contribution to software security and safety-critical systems.

\end{scontents}

\subsection*{Keywords}
\begin{scontents}[store-env=keywords,print-env=true]
% If you set the EnglishKeywords earlier, you can retrieve them with:
\InsertKeywords{english}
% If you did not set the EnglishKeywords earlier then simply enter the keywords here:
% comma separate keywords, such as: Canvas Learning Management System, Docker containers, Performance tuning
\end{scontents}
%\engExpl{\textbf{Choosing good keywords can help others to locate your paper, thesis, dissertation, \ldots and related work.}}
%Choose the most specific keyword from those used in your domain, see for example: the ACM Computing Classification System ({\small \url{https://www.acm.org/publications/computing-classification-system/how-to-use})},
%the IEEE Taxonomy ({\small \url{https://www.ieee.org/publications/services/thesaurus-thank-you.html}}), PhySH (Physics Subject Headings)\linebreak[4] ({\small \url{https://physh.aps.org/}}), \ldots or keyword selection tools such as the  National Library of Medicine's Medical Subject Headings (MeSH)  ({\small \url{https://www.nlm.nih.gov/mesh/authors.html}}) or Google's Keyword Tool ({\small \url{https://keywordtool.io/}})\\

%\textbf{Formatting the keywords}:
%\begin{itemize}
%  \item The first letter of a keyword should be set with a capital letter and proper names should be capitalized as usual.
%  \item Spell out acronyms and abbreviations.
%  \item Avoid "stop words" - as they generally carry little or no information.
%  \item List your keywords separated by commas (",").
%\end{itemize}    
%Since you should have both English and Swedish keywords - you might think of ordering them in corresponding order (\ie, so that the n\textsuperscript{th} word in each list correspond) - this makes it easier to mechanically find matching keywords.
\end{abstract}
\cleardoublepage
\babelpolyLangStart{swedish}
\begin{abstract}
    \markboth{\abstractname}{}
\begin{scontents}[store-env=lang]
swe
\end{scontents}

\begin{scontents}[store-env=abstracts,print-env=true]

Denna avhandling syftar till att ge rekommendationer för att koppla samman två minnessäkra programmeringsspråk, Rust och SPARK. Sådana kombinationer har redan studerats utförligt mellan Rust/SPARK och de osäkra språken C/C++, men det finns relativt lite information och forskning angående minnessäkra språk.

SPARK är en delmängd av Ada, ett språk som har använts i decenier i säkerhetskritiska applikationer. Rust är ett multiparadigmatiskt språk som har blivit populärt sedan dess framträdande för ungefär ett decennium sedan. Båda språken implementerar ägarskapssystem och typsäkerhet, vilka är avgörande för att utveckla säkra och tillförlitliga programvaror.

Minnesfel i C/C++ står för cirka 70 procent av de stora sårbarheterna i branschen, som rapporterats av organisationer såsom Microsoft, Apple och Google. Även om det finns verktyg för att undvika minnesfel kan koden inte göras säker retroaktivt, vilket skapar ett behov av språk som är designade med säkerhet i åtanke.

Att kombinera Rust och SPARK är en mycket lovande väg för systemprogrammering, låg nivå och säkerhetskritiska applikationer (bilindustri, flygavionik, medicinskt etc). 

Denna avhandling identifierar bästa praxis för säkra bindningar mellan Rust och SPARK, med fokus på att säkerställa minnessäkerhet, typsäkerhet och ägarskap, och analyserar sedan hur man kan behålla eller överföra dessa egenskaper. Avhandlingen ger klara rekommendationer baserade på kontrollstudieprogram och ett exempel med hjälp av BBQueue, ett cirkulärt buffertbibliotek som används i inbyggda system. Dessa resulat kan användas för att skapa säkra bindningar, manuelt eller med ett automatiserat verktyg.

Denna avhandling fyller en lucka i befintlig forskning, som främst fokuserar på att kombinera säkra och osäkra språk. Den bidrar värdefullt till programvarusäkerhet och säkerhetskritiska system.

\end{scontents}
\subsection*{Nyckelord}
\begin{scontents}[store-env=keywords,print-env=true]

\InsertKeywords{swedish}
\end{scontents}

\end{abstract}
\babelpolyLangStop{swedish}

\cleardoublepage

\section*{Acknowledgments}
\markboth{Acknowledgments}{}

I want to extend my heartfelt appreciation to Cyrille Artho and Elena Troubitsyna, who graciously agreed to work with me, notwithstanding the current shortage of supervisors and examiners. Cyrille's guidance, kindness, and availability have been particularly invaluable.

Gerald Q. ``Chip'' Maguire Jr. deserves special mention for his competence with \LaTeX, enduring patience, and insightful anecdotes on the dangers of ski slopes.

This work would have not been possible without the original idea of combining safe languages, a concept that must be credited to Florian Gilcher and Dr. Yannick Moy. Their vision and knowledge of all things Rust and all things Ada/SPARK laid a solid foundation for my research.

I would also like to express my gratitude to my wonderful colleagues at Ferrous Systems, past and present, as well as the AdaCore people. Their willingness to share their time, ideas, keyboards, offices, libraries, and advice has been instrumental. In particular, the BBQueue crate comes from the prolific mind of James Munns and was ported to SPARK by Fabien Chouteau. And for those wishing to reproduce this work, I highly recommend utilizing Johannes Kliemann's ``rust-gpr" crate. 

Lastly, I extend my deepest gratitude to my family, who have been a constant source of support and encouragement. Their love, care, piano, and singing have been a comfort during the long hours of work.

\acknowlegmentssignature

\fancypagestyle{plain}{}
\renewcommand{\chaptermark}[1]{ \markboth{#1}{}} 
\tableofcontents
  \markboth{\contentsname}{}

\cleardoublepage
\listoffigures

\cleardoublepage

\listoftables
\cleardoublepage
%\lstlistoflistings
 \listoflistings
 
%\engExpl{If you have listings in your thesis. If not, then remove this preface page.}
\cleardoublepage


% Align the text expansion of the glossary entries
\newglossarystyle{mylong}{%
  \setglossarystyle{long}%
  \renewenvironment{theglossary}%
     {\begin{longtable}[l]{@{}p{\dimexpr 3cm-\tabcolsep}p{0.8\hsize}}}% <-- change the value here
     {\end{longtable}}%
 }
%\glsaddall
%\printglossaries[type=\acronymtype, title={List of acronyms}]
\printglossary[style=mylong, type=\acronymtype, title={List of acronyms and abbreviations}]
%\printglossary[type=\acronymtype, title={List of acronyms and abbreviations}]
%\printnoidxglossary[style=mylong, title={List of acronyms and abbreviations}]

\cleardoublepage
%\glsaddall
\newglossarystyle{mydefs}{%
  \setglossarystyle{long}%
  \renewenvironment{theglossary}%
     {\begin{longtable}[l]{@{}>{\bfseries}>{\bfseries}>{\raggedright}p{3.5cm} p{0.85
     \hsize}}}% <-- change the value here
     {\end{longtable}}%
 }
%\printglossary[type=fullg,toctitle={Glossary}, style=myglossary, title={Full glossary}, nonumberlist]
\newgeometry{left=2cm,right=3cm,top=2cm,bottom=2cm}
\printglossary[type=fullg, style=mydefs, toctitle={Glossary}, title={Full glossary}]
%\setlength{\glsdescwidth}{0.9\hsize}
\restoregeometry

% if the nomenclature option was specified, then include the nomenclature page(s)
\ifnomenclature
    \cleardoublepage
    % Output the nomenclature list
    \printnomenclature
\fi

%% The following label is essential to know the page number of the last page of the preface
%% It is used to compute the data for the "For DIVA" pages
\label{pg:lastPageofPreface}
% Mainmatter is where the actual contents of the thesis goes
\mainmatter
\glsresetall

%% add all of the entries that are in glss.tex
%\glsaddall[types={fullg}]


\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\selectlanguage{english}
\chapter{Introduction}
\label{ch:introduction}
%\sweExpl{svensk: Introduktion}


%\sweExpl{Ofta kommer problemet och problemägaren från industrin där man önskar en specifik lösning på ett specifikt problem. Detta är ofta ”för smalt” definierat och ger ofta en ”för smal” lösning för att resultatet skall vara intressant ur ett mer allmänt ingenjörsperspektiv och med ”nya” erfarenheter som resultat. Fundera tillsammans med projektets intressenter (student, problemägare och akademi) hur man skulle kunna använda det aktuella problemet/förslaget för att undersöka någon ingenjörsaspekt och vars resultat kan ge ny eller kompletterande erfarenhet till ingenjörssamfundet och vetenskapen.\\slöser man en del eller hela delen av det ursprungliga problemet.\\Erfarenheten kommer ur en frågeställning som man i examensarbetet försöker besvara med tidigare och andras erfarenhet, egna eller modifierade metoder som ger ett resultat vilket kan användas för att diskutera ett svar på undersökningsfrågan.\\Detta stycke skall alltså, förutom det ursprungliga ”smala” problemet, innehålla  vad som skall undersökas för att skapa ny ingenjörserfarenhet och/eller vetenskap.}

%\engExpl{The first paragraph after a heading is not indented, all of the subsequent paragraphs have their first line indented.}
  
%This chapter describes the specific problem that this thesis addresses, the context of the problem, thegoals of this thesis project, and outlines the structure of the thesis.\\

%\generalExpl{Give a general introduction to the area. (Remember to use appropriate references in this and all other sections.)}

% One can use either biblatex or bibtex - set as the option for the document at the top of this file
%\ifbiblatex
%\engExpl{We use the \emph{biblatex} package to handle our references.  We
%use the command \texttt{parencite} to get a reference in parenthesis, like
%this \textbackslash parencite\{heisenberg2015\} resulting in \parencite{heisenberg2015}.  It is also possible to include the author as part of the sentence using \texttt{textcite}, like talking about the work of \textbackslash textcite\{einstein2016\} resulting in \textcite{einstein2016}.\\
%This also means that you have to change the include files to include biblatex and change the way that the \texttt{reference.bib} file is included.}
%\else
%\engExpl{We use the \emph{bibtex} package to handle our references.  We, therefore,
%use the command \textbackslash cite\{farshin\_make\_2019\}. For example, Farshin, \etal described how to improve LLC cache performance in in the context of links running
%at \qty{200}{Gbps}.}
%\fi

%\newpage
At the time of writing, Rust is still a relatively new programming language with a growing community (12 years old in 2023). Ada and SPARK have an established reputation in the safety-critical industry. Both languages provide \gls{memory-safety} guarantees through their \gls{ownership}-based paradigm. While there exist many frameworks and guidelines to combine both safe languages with C/C++ through \gls{foreign-function-interface}, there is little research or framework on how to effectively combine those two memory-safe languages to fully benefit from their strength and avoid pitfalls that can happen when using \glsxtrshort{FFI}. As our world becomes more interconnected, exploring the challenges of combining Rust and SPARK to provide clear recommendations for safe bindings is a timely and valuable contribution to the field of software security, systems programming, embedded and \gls{IoT}, and \gls{safety-critical} systems.


\section{Background}
\label{sec:background}
%\todo[inline]{There should be text here to introduce the subsections}
This background will cover memory unsafety, which is the underlying issue of this research.

%\generalExpl{Present the background for the area. Set the context for your project – so that your reader can understand both your project and this thesis. (Give detailed background information in Chapter 2 - together with related work.)
%Sometimes it is useful to insert a system diagram here so that the reader knows what are the different elements and their relationship to each other. This also introduces the names/terms/… that you are going to use throughout your thesis (be consistent). This figure  also help you later delimit what you are going to do and what others have done or  do.}

%\subsection{How sizeable is the problem when it comes to memory unsafe software?}
\subsection{How bad is memory-unsafe software?}
\label{sec:sizeOfProblem}

% Introduction glossary
% Maybe here?
%\newgeometry{left=3cm,right=3cm,top=2cm,bottom=2cm}

%\restoregeometry

This thesis mainly studies memory: its vulnerabilities in unsafe (typically C/C++) vs safe languages and memory vulnerabilities, and how they are addressed respectively.  

Attacks on memory in the literature and professional blogs list many exploits of software written in C/C++. The MITRE \glspl{CWE}\,\cite{noauthor_cwe_nodate} lists \gls{memory-safety} exploitation high on the list in parallel with improper input validation --- with examples, such as Out-of-bounds Write (1\textsuperscript{st}), Out-of-bounds Read (5\textsuperscript{th}) and use after free (7\textsuperscript{th}).

In a very widely cited blog article on memory safety issues in large code bases (million \gls{LOC}) written in C/C++, Alex Gaynor reports that the unsafe language itself causes 65\% of security vulnerabilities \,\cite{gaynor_what_2020}. Gaynor cites code bases such as Android (use-after-free, double-free, and heap buffer overflows representing over 65\% of bugs in Chrome and Android); Apple's iOS and macOS (between 66.3\% and 71.5\% memory safety bugs); Microsoft (70\%  memory safety issues); and the Ubuntu Linux kernel (65\% of Ubuntu security updates).

Gaynor provides other examples; however, the range of 65 to 70\% is consistent with academic literature\,\cite{mergendahl_cross-language_2022,scherer_engineering_2021, li_improving_2014}) and security blogs, such as the \gls{NSA} Software Memory Safety report published in 2022\,\cite{noauthor_nsa_2022}, or security white papers and software security books, such as~\cite{chapman_adacore_2018}.

Although some protections are deployed in common systems, such as stack cookies (which use an additional random placeholder value on the stack to detect memory changes), exception handler validation (which tests whether an exception is in a list
of valid handlers, before it is executed), data execution prevention (security feature that makes certain areas in memory non-executable), and address space layout randomization (consists in mangling the address space of a vulnerable process like libraries, main, heap, and stack, as well as memory-mapped files), several attack vectors are still effective"\,\cite{szekeres_sok_2013}, and it is impossible to make C/C++ code safe \emph{retroactively}. 

\subsection{Challenges to designing secure software}

Several authors have explained why designing secure software is extremely challenging. While the best solution would be to avoid writing software in C/C++ altogether, this is impractical and impossible\,\cite{szekeres_sok_2013}. Other sources recommend safe languages for new projects\,\cite{scherer_engineering_2021}. But for many reasons (especially cost and not reinventing the wheel when well-tested libraries exist), replacing unsafe languages is not on the map for most developers.

Moy and Aiello\,\cite{moy_when_2020} say that as products integrate and start to rely on software for their functionality and move from hardware-only to the cyber-physical space, they become vulnerable, which rings especially true for the \gls{safety-critical} industry. Furthermore, they warn that software complexity is increasing exponentially (\cite{moy_when_2020}), aggravating challenges to software security.

\begin{comment}
  \begin{figure}[!ht]
  \begin{center}
    \includegraphics[width=1\textwidth]{figures/complexity.png}
  \end{center}
  \caption[Software complexity, automotive/aerospace]{Software complexity in the automotive and aerospace industry from\,\cite{moy_when_2020}}
  \label{fig:complexity}
\end{figure}
\FloatBarrier  
\end{comment}


The authors\,\cite{moy_when_2020} report security incidents which brought down AT\&T (at the cost of US\$\,60 million and long-lasting damage to the company's reputation), the \gls{FDA} warned against almost 500 thousand cardiac devices that put the patients in pain or at risk of death, and the infamous WannaCry ransomware attack that encrypted 200 thousand computers in 150 countries with a reported cost of USD\$\,8 billion.

Scherer\,\cite{scherer_engineering_2021} reports successful attacks against ``train schedule systems, entire energy grids, hospital networks, vehicular control software, and even critical aircraft systems". Scherer notes that security needs to be built into the software development process instead of being an add-on or an afterthought. Scherer also notes the ``continuously increasing rate of bugs with increasing project size amongst other factors in long-lived projects" and ``a slow turnaround time" for software improvement (1 to 10 years) causes problems to pile up.

Regarding security, the software developer also faces a series of asymmetries\,\cite{chapman_adacore_2018}, in capability (the attackers skills do not grow linearity), in efforts, knowledge and impact (the destructive impact of security failures are unpredictable). Scherer notes that any defect is guaranteed to be exploited when discovered as malicious actors systematically screen for issues. As a result, the risk that said defect is found the attacker is much higher than detection during testing\,\cite{scherer_engineering_2021}.


\section{Sustainability considerations}

Sustainability is an important concern while developing technology or advocating for its use. When it comes to the use of programming languages, considering energy consumption is essential and in line with SGD development goals 9 -- Industry, Innovation and Infrastructure --, 12 -- Responsible Consumption and Production -- and 13 -- Climate Action --\cite{noauthor_envision2030_nodate}. As studied by Pereira \etal\,\cite{pereira_energy_2017}, Ada and Rust energy consumption are comparable to C, and both languages are a good choice for energy-conscious development when it comes to various aspects, such as time, memory, and energy usage. This point is defended by companies such as AWS\,\cite{miller_sustainability_2022}, which pinpoints the increasing demand for data consumption and processing, emerging demand for \glsxtrshort{IoT} and ML applications. Broad adoption of energy-efficient programming languages could greatly reduce the energy consumption of computing by 50\%\cite{miller_sustainability_2022}.

\section{Problem}
\label{sec:problem}

Research and technical blogs recommend that programmers use memory-safe languages for new projects. They also recommend being extremely careful when using \glsxtrfull{FFI} as the boundary between two programming languages, as assumptions on both sides may not hold. 

\textbf{While frameworks and guidelines exist for C/C++, how is this implemented practically when programmers or organizations want to combine two well-known memory-safe languages?}

\subsection{Assignment provider and objective}

The research project is conducted in cooperation between Ferrous Systems and AdaCore. Both companies are engaged in an effort to provide a certified version of the Rust compiler through the Ferrocene initiative\,\cite{noauthor_ferrocene_2023}. This initiative would greatly benefit the \gls{safety-critical} industry by bringing Rust guarantees to software that \emph{should never} fail.

% Research Question
\subsection{Research question}
\label{sec:researchQuestion}

What are the best practices for secure bindings between Rust and SPARK code?

Sub questions: How can we ensure that \first \gls{memory-safety}, \Second \gls{type-safety}, and \third \gls{ownership} are maintained in these bindings?

\subsection{Hypothesis}
We hypothesize that the internal coherency of both languages can be maintained if we can provide recommendations for the safe use of combined Rust/SPARK code.

\subsection{Objectives}
The tasks must be fulfilled to answer the research question:
\begin{enumerate}
    \item Write a series of control study programs that examine the memory safety, type safety, and ownership of Rust and SPARK code when combined.
    \item Use a circular buffer library, which is implemented in both Rust and SPARK\,\cite{munns_bbqueue_2022,chouteau_bbqueue_nodate}, as a larger code base to experiment with bindings between the two languages
    \item Use the information gathered from the control study programs and the BBQueue library to identify good practices for bindings between Rust and SPARK code.
\end{enumerate}


\section{Purpose}
%\sweExpl{Syfte}
%\sweExpl{Skilj på syfte och mål! Syfte är att förändra något till det bättre. I examensarbetet finns ofta två aspekter på detta. Dels vill problemägaren (företaget) få sitt problem löst till det bättre men akademin och ingenjörssamfundet vill också få nya erfarenheter och vetskap. Beskriv ett syfte som tillfredställer båda dessa aspekter.\\
%Det finns även ett syfte till som kan vara värt att beakta och det är att du som student skall ta examen och att du måste bevisa, i ditt examensarbete, att du uppfyller examensmålen. Dessa mål sammanfaller med kursmålen för examensarbetskursen. 
%}
%\generalExpl{State the purpose  of your thesis and the purpose of your degree project.\\
%Describe who benefits and how they benefit if you achieve your goals. Include anticipated ethical, sustainability, social issues, etc. related to your project. (Return to these in your reflections in Section~\ref{sec:reflections}.)}

The purpose is to provide safe and practical recommendations that could be used by organizations or individual programmers, that are orienting themselves toward memory-safe languages.

\section{Goals}
%\sweExpl{Mål}
%\sweExpl{Skilj på syfte och mål. Syftet är att åstakomma en förändring i något. Målen är vad som konkret skall göras för att om möjligt uppnå den önskade förändringen (syfte). }

%\generalExpl{State the goal/goals of this degree project.}

The goal of this project is to study the safe combination of Rust and SPARK and provide guidelines. This has been divided into the following three sub-goals:

\begin{enumerate}[leftmargin=*, label=\textbf{Subgoal \arabic*}, ref={Subgoal \arabic*}]
\item\label{sg:selectdatatypes} Select appropriate existing data types for control studies.
\item\label{sg:safebindings} Implement control studies in a series of safe bindings.
\item\label{sg:providesafebindings} From lesson learned from \ref{sg:safebindings}, provide safe binding in a more complex library.
\end{enumerate}

%\generalExpl{In addition to presenting the goal(s), you might also state what the deliverables and results of the project are.}

\section{Research Methodology}
%\sweExpl{Undersökningsmetod}
%\sweExpl{Här anger du vilken vilken övergripande undersökningsstrategi eller metod du skall använda för att försöka besvara den akademiska frågeställning och samtidigt lösa det e v ursprungliga problemet. Ofta kan man använda ”lösandet av ursprungsproblemet” som en fallstudie kring en akademisk frågeställning. Du undersöker någon intressant fråga i ”skarpt” läge och samlar resultat och erfarenhet ur detta.\\
%Tänk på att företaget ibland måste stå tillbaka i sin önskan och förväntan på projektets resultat till förmån för ny eller kompletterande ingenjörserfarenhet och vetenskap (ditt examensarbete). Det är du som student som bestämmer och löser fördelningen mellan dessa två intressen men se till att alla är informerade. 
%}
%\generalExpl{Introduce your choice of methodology/methodologies and method/methods – and the reason why you chose them. Contrast them with and explain why you did not choose other methodologies or methods. (The details of the actual methodology and method you have chosen should be in methods. Note that in Chapter~\ref{ch:methods}, the focus could be research strategies, data collection, data analysis, and quality assurance.)\\
%In this section you should present your philosophical assumption(s), research method(s), and research approach(es).}
The objective of this thesis is to procure a series of recommendations ("\textit{Do's}") that can be applied, for example, to create an automated tool for bindings on the model of \texttt{bindgen}\,\cite{noauthor_bindgen_2022}.\footnote{As a reminder, bindgen is a binding tool that generates bindings between Rust and C.} 
The languages we analyze in this thesis have richer types than C, and the goal is to take advantage of their expressivity. Both languages also implement type safety and ownership, and we study how those are passed or conserved through \gls{FFI}.

\Needspace*{5\baselineskip}
The binding is considered correct if the data is correctly passed and no memory error is found \texttt{valgrind} - this does not prove complete correctness but rather the absence of memory error. But our goal is to pass the correct type through the \gls{FFI} barrier, and rely on both languages' guarantees once the \gls{FFI} frontier is passed. 

The method chosen is manually doing those bindings through control studies and analyzing them with the help of the documentation for each type as well as memory tools to ensure the binding is correct and that there is no memory leak. 

This method is reliable and appropriate as big programs are built from smaller modular pieces. In addition, \gls{FFI} research is carried out from control studies in surveyed literature. Possible issues, including safety issues, are demonstrated with the help of control studies. Control studies allow replicating the necessary complexity that is needed for illustration purposes. Control studies also allow full control over layout and alignment when passing chosen data types and data structures.
Small control study programs are useful when illustrating best practices for memory safety, type safety, and studying how ownership s transferred or maintained.
Control study programs can provide a foundation for automatic tooling.

After the control studies are performed, an additional experiment is executed with a BBQueue, a complex library available in both languages. Porting BBQueue allowed to implement most of the "lesson learned" through the control studies.


\section{Delimitations}


This thesis will go through manual bindings for increasingly complex types and will not implement an automated tool, which is future work.

\section{Structure of the thesis}
%\sweExpl{ Rapportens disposition}
~\Cref{ch:background} presents relevant background information about Rust and SPARK, and talks more about memory safety.  
~\Cref{ch:relatedworks} discuss related works when it comes to \gls{FFI}.  \Cref{ch:methods} presents the methodology and method used to solve the problem. ~\Cref{ch:resultsAndAnalysis} discuss the outcome of the experiments, and ~\Cref{ch:conclusionsAndFutureWork} present possible expansion of this work.


%\setglossarysection{section}
% The following line removes the glossary title.
%\renewcommand{\glossarysection}[2][]{}
% Add everything from this glossary
%\glsaddall[types={introductiongloss}] 
%\printglossary[type=introductiongloss, style=mydefs, 
%toctitle={Terms in the introduction}, 
%title={Terms in the int• The statistic tool is available here.roduction}
%]


\cleardoublepage\chapter{Background}
\label{ch:background}

This thesis covers the interaction of Rust and SPARK and which safety guarantees are retained when both languages are combined. Both languages implement \gls{memory-safety} but combining them in the same program requires clear recommendations. 

The background is composed of two parts. 
In Part 1, we present a 
high-level description of Rust and SPARK(\Cref{sec:rust_and_spark}), and what makes them desirable programming languages in terms of memory safety, \gls{type-safety}, as well as the concept of \gls{ownership} they both implement.

In Part 2, we discuss (\Cref{sec:software_safety}) \gls{memory-safety} in software and why the industry and researchers believe safe languages are considered to be a solution to common \gls{memory-error}s and attacks. In this part, historical memory errors and attacks are discussed to understand the protection offered by safe languages. 

\section{Background: Rust and SPARK}
\label{sec:rust_and_spark}

This section covers Rust and SPARK and describes what makes them memory safe according to the literature and their official documentation. This section explains why those two languages are relevant for \gls{safety-critical} industries and for software safety.


\subsection{Rust}

Rust is designed as a systems programming language\,\cite{mergendahl_cross-language_2022}, to interact with other low-level languages. Rust focuses on speed, \gls{memory-safety}, and concurrency. Thus, Rust is multi-paradigm and combines features from imperative \textit{and} functional programming. It is fully open-source and has a six-week release cycle, with backward compatibility guaranteed\,\cite{poveda_ruiz_bounded_2019,noauthor_rust_nodate}. Rust is characterized by its ``strong performance and safety properties". In addition, the language combines a strong type system enforced at compile-time, and other compile-time checks, to prevent ``large classes of memory bugs"\,\cite{mergendahl_cross-language_2022}. Furthermore, Rust ensures spatial safety by performing compile-time checks for statically-sized objects. For dynamically sized objects, instructions are passed to the binary, to delay those checks until runtime.

For temporal safety, Rust relies on its concept of ownership --- a concept shared by SPARK. As described by Mergendahl \etal\,\cite{mergendahl_cross-language_2022}, Scherer\,\cite{scherer_engineering_2021}, and Poveda Ruiz\,\cite{poveda_ruiz_bounded_2019} as well as the official documentation\,\cite{noauthor_rust_nodate}, a unique owner for a value can exist at a time and the value is destroyed when the unique owner goes out of scope.  This implies that when a value is destroyed, the reference is nullified, without the need for garbage collection. The Rust compiler adds lifetimes to all values, which is a ``tag" guaranteeing the value is still valid. The borrow checker ensures that no value outlives its lifetime.
 
To relax this strictness, Rust can temporarily transfer ownership, known as borrowing. More importantly, Rust allows one mutable reference \inlinecode{\& mut T} or multiple immutable references to co-exist \inlinecode{\&T} simultaneously --- these two scenarios are exclusive. References carry several assumptions: \first they are never null and \Second they points always to valid data. 
This  protects against type-related errors at compile-time, as rustc (the rust compiler) warns of any error. An example of code\footnote{A note on special syntax: \texttt{!} is used to use a macro, here is a \texttt{Vector}. \texttt{\{:?\}} is used to print variables in \texttt{Debug} format.} that shifts ownership is shown in \Cref{lst:rust_ownership}.
 
\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{rust}
// a is a vector, it is heap-allocated
let a = vec![1, 2, 3]; 
// ownership of a is moved to b
let b = a;             
println!("b: {:?}", a);
\end{minted}
\caption[Rust code showing ownership]{Rust code showing ownership}
\label{lst:rust_ownership}
\end{listing}
%\FloatBarrier

In addition, Rust's type system statically rules out data races. At its heart, the Rust type-system has the concept of ownership. In the Rust ownership system, many aliases can exist to a place in memory, but only one alias can give mutable access, that the capacity to write to this place in memory. If ownership is shared between many aliases, then those aliases can only read the contents of this place in memory. The restrictions linked to borrowing ensure that a value is unable to exist in memory without an owning variable in the same scope, and it is impossible to modify a variable from different threads, preventing data-races\,\cite{poveda_ruiz_bounded_2019,noauthor_rust_nodate}.\footnote{There are of course ways to implement thread safety such as channels or atomic reference counters (\texttt{Arc} in Rust terminology) but this is a general overview.}

The system of ownership is not applied to simple types as the compiler knows their size at compile-time. Those types are known to implement the \texttt{Copy trait}. This trait means that the compiler can copy those types \emph{without} needing to transfer ownership. Some simple types implementing the copy traits are integers, for example, ``i32" or ``u64". Those types are called \gls{copy-type}.

Rust allows unsafe operations that are fenced by the keyword \texttt{unsafe\{\}}. Inside unsafe brackets, operations such as raw pointer manipulation, or initialization of unsafe objects are possible, under the programmer's responsibility. Unsafe blocks are used mainly to interact with low-level code.

Rust does not implement exceptions, but has an error management system, distinguishing between recoverable and unrecoverable errors. Recoverable errors can be managed by the program, while unrecoverable errors make the program stop and unwind the stack --- resulting in a so-called \texttt{panic}. The programmer decides when an error is handled gracefully and when the program should panic.

In the somewhat contrived  example shown in \Cref{lstlisting:data_race}, we see that the compiler does not accept modification of a global variable from different threads. The compiler warns about aliasing violations or potential data races that cause undefined behavior.
\begin{listing}[!ht]
\begin{minted}[
%frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
%linenos
]{rust}
static mut SHARED: i32 = 0; // Global scope
fn main() {
   let cls = thread::spawn(move || {
        for _ in 0..10000 {
        // aliasing violation happens here!
            SHARED += 1;
        }
   });
   for _ in 0..10000 {
      SHARED += 1;
   }
}
\end{minted}
\caption[Rust code showing aliasing violations]{Rust code showing aliasing violations}
\label{lstlisting:data_race}
\end{listing}
\FloatBarrier

\Needspace*{5\baselineskip}	
In contrast, if we frame the variable ``SHARED" inside \texttt{unsafe} blocks, the program compiles and runs, and prints all possible results between 100000 and 200000, as expected from a data race. This is an example of what \texttt{unsafe} allows the programmer to do: more freedom but it makes Rust as memory-safe as any C/C++ program.

\begin{listing}[!ht]
\begin{minted}[
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
]{rust}
    let cls = thread::spawn(move || {
        for _ in 0..100000 {
            unsafe {
                SHARED += 1;
            }
    // ...
        unsafe {
            SHARED += 1;
        }
    //...
    unsafe {
        print!("Shared {shared}");
    }
}
\end{minted}
\caption[Rust code showing a data race]{Rust code showing a data race }
\label{lstlisting:data_race2}
\end{listing}
\FloatBarrier



\subsection{Ada}

Ada is a high-level programming language, designed for long-term applications that should not be dependent on software updates -typically the safety-critical industry. It was developed in the early 1980s and has a syntax inspired by the Pascal language family.
Chapman and Moy\,\cite{chapman_adacore_2018} list some of Ada's advantages. First, its syntax protects from assignment and comparison (a well-known C problem!) as well as the unintentional use of \texttt{NULL} or the dangling else problem. In addition, there is no explicit use of pointers and its strong typing system prevents confusion or abusive type promotion. Furthermore, it has many features for concurrency.

Ada has strong type safety as in Rust. Additional constraints can be imposed with subtypes or bounds. This ensures at compile-time that data is only used in ways that are consistent with its declared type and that type-safety is not violated.

 \begin{listing}[!ht]
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
    ]{ada}
    -- those are not the same type, and it is impossible
    -- to assign those interchangeably.
    type My_int is range -1 .. 20;
    type My_int2 is range -1 .. 20;
   
   -- same here!
   subtype MyInteger1 is Integer range 0..10;
   subtype MyInteger2 is Integer range 5..15;
\end{minted}
\caption[Ada/SPARK code showing type guarantees]{Ada/SPARK code showing type guarantees}
\label{lstlisting:spark_datatypes}
 \end{listing}

\subsection{SPARK}

%\gls{safety-critical}

SPARK refers to a set of tools for verification as well as the language name.
SPARK allows formal verification of code to provide guarantees that would not be achieved otherwise at multiple levels of assurance, which can be integrated into development processes (Moy, in direct conversation). The language is designed to be the largest subset of Ada that is ``still amenable to simple specification and sound verification", and as such, the use of pointers (which permits aliasing!) was not a part of the language until fairly recently\,\cite{jaloyan_safe_2017, dross_using_2019}.\footnote{At the time of writing, 2014.}

 SPARK supports, amongst other features, basic data, control flow analysis, ineffective assignments, and exhaustive detection of uninitialized variables. To ensure the safety and security of software systems, SPARK provides support for mathematical proofs. These proofs can be used to demonstrate the absence of runtime exceptions, verify the fulfillment of security and safety properties, or establish that the software follows its specifications and has the required behavior\,\cite{noauthor_spark_nodate}.
 
Carré and Garnsworthy\,\cite{carre_spark_1990} describe the rationale behind the design of SPARK, highlighting a number of key requirements that the language must meet to be effective in safety-critical programming contexts. These include being logically sound and free of ambiguities, having a simple and formal definition, maintaining expressive power to support rigorous program development and faithful representation of abstractions, prioritizing security and reliability to ensure that errors are not tolerated in safety-critical contexts, and finally, the ability to be verifiable.

SPARK is compiled with the Ada compiler, (GNAT is used in the experiments in this thesis) but it has in addition the SPARK checker. SPARK verifies contracts are always upheld, insuring no runtime error, proving for example that no division by zero is possible or that the result of an increment is always bigger than the number sent to the program. In addition, SPARK ensures thread safety via synchronized objects (Scherer\,\cite{scherer_engineering_2021}, SPARK resources\,\cite{noauthor_spark_nodate}).

As an example from AdaCore documentation (\Cref{lstlisting:spark_illegal_transfer}), this program is legal in Ada but illegal in SPARK, as the operation on \texttt{X} is not benign, meaning that we are trying to make an assignment to the contents of a pointer whose \gls{ownership} has been moved to \texttt{Y}. Once \texttt{Y} has ownership of the data contained in \texttt{X}, it becomes impossible to manipulate \texttt{X}.

\begin{listing}[!ht]
    \begin{minted}[
    %frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\footnotesize,
    linenos
    ]{ada}
    procedure Ownership_Transfer is
       type Int_Ptr is access Integer;
       X     : Int_Ptr;
       Y     : Int_Ptr;
       Dummy : Integer;
    begin
       X     := new Integer'(1);
       X.all := X.all + 1;
       Y     := X;
       -- legal, ownership pertains to Y
       Y.all := Y.all + 1;  
       -- illegal, trying to access a variable through X,
       -- which was moved. No further operations, 
       -- assignment and transfer are possible.
       X.all := X.all + 1;  
       X.all := 1;          
       Dummy := X.all;      
    end Ownership_Transfer;
    \end{minted}
    \caption[Illegal ownership transfer in SPARK]{Illegal ownership transfer in SPARK}
    \label{lstlisting:spark_illegal_transfer}
\end{listing}

Pointer ownership in SPARK took inspiration from Rust\,\cite{dross_using_2019}, with some differences. In SPARK, only read aliasing is allowed, as per the Concurrent-Read-Exclusive-Write (CREW) model~\cite{moy_proof_2019}. SPARK checks the absence of aliasing on write at the call site. Pointer assignment operates as a transfer of ownership, where the source object loses permission to the underlying object as per \Cref{lstlisting:spark_illegal_transfer}. Once ownership is transferred, the original owner is not valid. Begning aliasing, or local handles on data with pointers ``borrow" for read, called \emph{observability}.

\Needspace*{4\baselineskip}
In SPARK, pointers have nominal equality instead of structural equality; thus, \inlinecode{type T1 is access Integer} will not be equal to \inlinecode{type T2 is access Integer}, even if both are pointers to Integers. In Ada/SPARK pointers cannot escape as they are protected by their types. 


\subsection{Summary on Rust and SPARK}

The concept of type safety and ownership, and why these traits are considered desirable in safe programming languages like Rust and SPARK, have been covered in detail. Those traits are their use of strong \gls{type-safety} and ensuring \gls{memory-safety} through \gls{ownership}. This reduces the probability of \gls{memory-safety} errors as SPARK does not fail at runtime and the Rust compiler maintains its guarantees as long as the programmer does not use \texttt{unsafe} wrongly.

%\newpage

\section{Background: Software Safety}
\label{sec:software_safety}

The literature around the state of software security generally agrees about the threats caused by memory-safety issues and the underlying reasons for those threats, namely unsafe languages. 

\subsection{Memory safety}

Skezeres \etal\,\cite{szekeres_sok_2013} (in ``SoK: Eternal War in Memory") and Pal \etal\,\cite{pal_memory_2016} (in ``Memory Corruption-Basic Attacks and Counter Measures") define \gls{memory-safety} in terms of protection against \gls{memory-error}s. 
In the C++ standard, writing out-of-bounds of an array, dereferencing null pointers, or reading uninitialized variables results in undefined behavior. Buffer overflows (writing outside of the allocated space in memory), double-frees (freeing the memory twice), and use after free (accessing a memory that has been freed before) are very common errors\,\cite{szekeres_sok_2013,scherer_engineering_2021}. 
These errors can be leveraged into full-fledged attacks, as ``every exploit starts by triggering a memory error"\,\cite{szekeres_sok_2013}. The attack process is two-fold. The first is to make a pointer invalid, and the second is dereferencing this invalid pointer. Attackers can exploit either dangling pointers (\ie temporal errors) or an out-of-bound pointer (\ie a spatial error). These attack techniques can be combined and chained for successful exploitation. 
%as illustrated in detail in \Cref{fig:sok}.

\Needspace*{17\baselineskip}
\subsection{The ``Memory Wars"}.

C/C++ are especially susceptible to \gls{memory-error}s, because of the freedom they give to the programmer. Szekeres \etal\,\cite{szekeres_sok_2013} call the \gls{memory-corruption} bugs in low-level languages ``one of the oldest problems" in security. Memory errors have been exploited for 30 years, while real-world exploits prove that protections can always be defeated. The authors established that not only does a completely secure system not exist, but protection mechanisms never achieve wide adoption by the software engineering community. The reason is that protection mechanisms present a significant overhead, in terms of performance (\eg garbage collectors are costly in systems relying on speed, not even to mention changing the programming language, and the trade-off is not worth the benefit of the protection) or more simply the cost of replacing billions of lines of existing C/C++ is too expensive. According to Skezeres \etal\,\cite{szekeres_sok_2013} the issues may be that the protection is not robust enough or there exist problems of incompatibility with legacy code and dependencies.

\begin{comment}
    
  \begin{figure}[!ht]  \centering 
\includesvg[inkscapelatex=false, scale=0.4]{figures/figuressvg/redrawn_memory_attack.svg}
\caption{Redrawn figure}
\end{figure}
\FloatBarrier  




\begin{sidewaysfigure}[!ht]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figures/sok.png}
    %\includesvg{figures/sok.svg}
  \end{center}
  \caption[Attack model demonstrating four exploit types and policies mitigating the attacks in different stages by Szekeres \etal\,]{Attack model demonstrating four exploit types and policies mitigating the attacks in different stages by Szekeres \etal\,\cite{szekeres_sok_2013}  \textcopyright2013 IEEE}
  \label{fig:sok}
\end{sidewaysfigure}

\end{comment}

To mitigate these problems, various tools have been introduced\,\cite{mergendahl_cross-language_2022}. Dynamic analysis tools observe the program while it is running, while static analysis tools analyze the source code. Such tools are for example Valgrind, sanitizers (dynamic analysis), or the Clang static analyzer. Even if writing analysis tools is, to say the least, ``non-trivial"\,\cite{scherer_engineering_2021}, some authors studied in the frame of this thesis wrote their own (FFIChecker by Li \etal\,\cite{li_detecting_2022} and Scherer who participated to the project Miri\,\cite{noauthor_miri_2023}). Tools have limitations: dynamic analysis tools are time-consuming and specific to the input, and static analysis tools have false positives\,\cite{li_improving_2014}.
Unfortunately, those tools provide very limited protection, in part because the software engineering community is facing professionalization and an increase in complexity from the attacking side\,\cite{scherer_engineering_2021, chapman_adacore_2018}. 
According to Mergendahl \etal\,\cite{mergendahl_cross-language_2022}, ``sanitizers suffer from coverage limitations", with many missed bugs as a consequence, while ``enforcement-based exploit mitigation techniques" can still allow attacks that do not violate their policies as they are ``relaxed enough", and randomization techniques remain susceptible to information leakage.
\FloatBarrier



\subsection{The monopoly of C/C++}

Both C/C++ are considered as building bricks of modern software, in systems programming and embedded because of the performance they offer, as argued by Mergendahl \etal and Scherer \,\cite{mergendahl_cross-language_2022, scherer_engineering_2021}. Both C/C++ are also prevalent in embedded systems (Moy and Aiello\,\cite{moy_when_2020} Chapman and Moy\,\cite{chapman_adacore_2018}). Renouncing C/C++ is equivalent to renouncing performance and losing the fine-grained control necessary to work with low-level systems.
C/C++ are by nature unsafe languages. They are designed for direct interaction with memory and can modify it without any restriction. Mergendahl \etal state that the underlying root of all evil, \gls{memory-corruption}, comes from the error-prone process of delegating all security checks to the programmer. As a consequence, developer errors introduce both spatial and temporal errors.

The inherent unsafely of C/C++ affects safe languages. By design, Rust and Ada (and its subset SPARK) are designed to interact with existing low-level applications written in C/C++, and use dependencies written in unsafe languages. 

\section[FFI in software engineering]{FFI in software engineering}

\glsxtrshort{FFI} is commonly used in systems programming languages. 
To write software with FFI in general, as well as in this thesis, it is important to follow existing guidelines\,\cite{gjengset_rust_2021, noauthor_ffi_nodate, noauthor_multi-language_nodate}. 
Those guidelines cover important points such as calling conventions (that is to say, the data representation that the compiler is expect) or symbols, which must be deterministically generated. Error management is critical, as unwinding an error through an FFI barrier is considered undefined behavior. Type matching is also an important consideration, as one language possesses no information on the representation of complicated types in another language. We consider memory management (when to keep and release ownership) which most of the time must be returned to the appropriate allocator according to guidelines\,\cite{gjengset_rust_2021}. 

In ``Improving Quality of Software with Foreign Function Interfaces using Static Analysis", Li\,\cite{li_improving_2014} covers the reason for FFI prevalence in modern software. FFI is a gluing layer that allows the connection of software written in different languages. Multi-language software seems ``prevalent and necessary"\,\cite{li_detecting_2022}: different languages have different strengths due to design choices, or rich ecosystems, or have a specific use for ``performance-critical scenarios" in a time where software development requires faster processes, higher quality, and faster time to market.

Some problems arise only in multi-language contexts as failures can be caused by wrong assumptions. ``Rust’s automatic memory management relies on it being the only entity controlling the allocation status of memory"\,\cite{mergendahl_cross-language_2022} --- but this may not be the case. Rust uses \texttt{malloc()} and shares a heap with other components of multi-language applications. So, ``Rust’s spatial memory safety can rely on bounds stored in memory which is only safe if the entire application is memory safe"\,\cite{mergendahl_cross-language_2022}.

\glsxtrfull{CLA} show, counter-intuitively, that multi-language applications are weakened by the very assumption the programmer has about combining different languages' strengths. Instead, it is each language's \emph{weakness} that threatens to become the weakest link of the application.
For example, hardened C through \gls{CFI}, prevents control-flow hijacking by checking the validity of pointers. The Rust side provides protection against the same attacks by enforcing memory safety. However, this does not make the C side memory safe, and Rust does not validate the code pointers --- it just assumes \gls{memory-safety} in the whole memory space. The attacker can take advantage of the C language weaknesses to combine memory corruption and non-validated pointers in Rust. 

Mergendahl \etal\,\cite{mergendahl_cross-language_2022}, insist that the problem is much deeper than what meets the eye. They could demonstrate control-flow hijacking, but the ``weakest link principle holds for any element of an application’s threat model that varies across languages". If one part of the code introduces code signing and validation (on the Rust side), but another part of the code does not (C libraries), then the cross-language application remains completely vulnerable to supply chain attacks.

Finally, the authors introduce the most ``insidious case of multi-language applications". The component languages can have eliminated a threat but use different assumptions. The result is that ``the combination of two safe languages itself being unsafe", a theory that is of the utmost interest in the frame of this thesis --- as both Rust and SPARK are safe languages.

The authors also underline that the cost of writing such attacks is relatively simple: while attacks on single-language code require ``new primitives", \glsxtrshort{CLA} opens a new avenue of attack reusing old vulnerabilities ``brought back to life" ---the attack that we surveyed in \Cref{sec:software_safety}, in addition to CLA specific vulnerabilities. The authors call those attacks ``revenant vulnerabilities"\,\cite{mergendahl_cross-language_2022}. 

\section{Summary}

Memory safety is a primary concern in low-level and systems programming, with constant research for its improvement (\Cref{sec:software_safety}). Ameliorating the state of affairs is challenging, in terms of cost and trade-offs.

\cleardoublepage

%\chapter[Related works: Foreign Function Interface]{Related works: Foreign\linebreak[4] Function Interface}
\chapter{Related works}
\label{ch:relatedworks}

Related works examine dependencies, language formalization, and studies around \glsxtrfull{FFI}.

\section{Dependencies}
\label{subsec:dependencies}

Safe systems programming languages can be dependent on libraries written in unsafe languages. Even if those dependencies are well-tested, they still represent a safety risk. As a result, the inherent unsafely of C/C++ can affect safe languages. Rust is designed to interact with existing low-level applications written in C/C++ but can also depend on libraries written in C/C++. This is different from SPARK, which only depends on Ada, even if programmers can interface with C/C++ as any system programming language.

While the consensus is that the Rust language is excellent in reducing memory-safety issues, Evans \etal examined the actual usage of Rust by developers in their paper ``Is Rust Used Safely by Software Developers?"\,\cite{evans_is_2020} and their conclusions are somehow different. They note that \texttt{unsafe\{\}} --- a Rust keyword to do memory operations not authorized by the compiler \footnote{See more details in \Cref{sec:rust_and_spark}.} is used in one-third of dependencies which are impossible to check. They believe ``propagation of unsafeness offers a challenge to the claim of Rust as a memory-safe language". In this case, Evans \etal recommend changes to the rust compiler to raise awareness in programmers when their code is rendered unsafe through dependencies. 

\Needspace*{11\baselineskip}
But Evans \etal do not quantify their findings. Li \etal (in ``Detecting Cross-Language Memory Management Issues in Rust"\,\cite{li_detecting_2022}), analyzed whether  Rust could realize its promised guarantees and found that more than 70\% of packages on \texttt{crates.io} have at least one unsafe binding. This result is based upon their looking at approximately 77,000 packages. Finally, Li \etal built a \gls{FFI}-checker tool that found only 34 bugs in 12 packages out of a sample of 984 packages. The authors consider this result of great significance (probably because of Rust's memory safety reputation) as the bugs were previously unknown and were subsequently reported by the authors in a GitHub trophy case \,\cite{li_rust-ffi-checkertrophy-case_nodate}. The relatively low number of bugs seems to strengthen the consensus around safety guarantees provided by Rust.

\section{Formalization}

Rust is an open-source project without formal specifications, contrasting with Ada and SPARK. But there are many efforts ongoing to formalize Rust. The Rust Belt\,\cite{jung_rustbelt_2018} project aims ``to equip Rust programmers with the first formal tools for verifying safe encapsulation of unsafe code". Rust Belt defines a set of rules to model Rust programs and uses those rules to prove the security of those programs mathematically. Rust Belt has demonstrated the safety of basic typing and that there is no undefined behavior in well-typed Rust \,\cite{xu_memory-safety_2021}. 

The Ferrocene language specification (a collaboration between Ferrous Systems and AdaCore\,\cite{noauthor_ferrocene_2023}) aims to document the behavior of the Rust compiler in a standardized form. The goal is to qualify a version of the Rust compiler for use by safety-critical industries.

SPARK is built upon the Ada standard ISO/IEC 8652:2012\,\cite{1400-1700_isoiec_2013}, which defines the form and meaning of programs to ensure the portability of Ada code. Specifically, SPARK Pro is a group of static analysis tools which use formal methods to verify SPARK deductively. This tool can meet several high-assurance standards, including DO-178B/C (and the Formal Methods supplement DO-333), CENELEC 50128, IEC 61508, and DEFSTAN 00-56\,\cite{jaloyan_safe_2017}.

\section{Software written with FFI}

Previous publications have found many issues when combining safe and unsafe languages, making the multi-language program weaker than the sum of their part. But even a combination of safe languages can be expected to be unsafe.

With this goal in mind, we set aside discussions on \gls{memory-safety} in single-language applications (such as Regehr \etal and Chandra \etal focusing on C\,\cite{regehr_efficient_2006,chandra_physical_1999}), and papers too tightly centered around security (such as the work on the formalization on exploits by Dullien\,\cite{dullien_weird_2020}). 

In this part, we review again the work of Mergendahl \etal\,\cite{mergendahl_cross-language_2022} whose paper is an inspiration for this thesis, Li's work on improving FFI software safety\,\cite{li_improving_2014}, Scherer work on software safety\,\cite{scherer_engineering_2021} and Li \etal\,\cite{li_detecting_2022}, who built on Mergendahl \etal work. For a formal expression of the need for linking type, we can refer to the work of Patterson and Ahmed\,\cite{patterson_linking_2017} on using richer types available in other languages and linking those types modeled in abstract compilers.

Software built with FFI layers can be listed easily\,\cite{li_improving_2014,li_detecting_2022,mergendahl_cross-language_2022}: the \gls{JNI} which glues together the \gls{JDK} and it's core systems libraries written in C and C++, the Android mobile \gls{OS} which includes a Java \glsxtrfull{VM} and a C/C++ kernel; Firefox --- studied extensively by Mergendhal \etal which is also a well-known example. The Linux kernel is integrating Rust as a core language.\footnote{At the time of writing this thesis.} The Tor project, Microsoft Windows \gls{OS}, and Google Fuchsia can also be named.

\subsection{How to evaluate quality in FFI bindings}

Li distinguishes four software quality issues caused by \glsxtrshort{FFI}: security, reliability, safety, and performance\,\cite{li_improving_2014}.

\begin{description}[labelwidth=\widthof{\textbf{Memory safety}}, leftmargin = !]
\item[\textbf{Security}] implies that an attacker is not in a position to exploit the FFI layer for security attacks. 
\item[\textbf{Reliability}]implies that the system should not behave unexpectedly because of its FFI layer(s).
\item[\textbf{Safety}] implies that multi-threaded execution is safe. This property has been studied extensively but only for uni-language systems and is not relevant for FFI. Commonly, safety issues involve deadlocks and race conditions, synchronization in threads, and data integrity. While the present thesis does not investigate multi-threading, it is important to stress that it is a core issue in FFI safety.
\item[\textbf{Performance}] Performance issues are mostly related to poor memory management (memory leaks, dangling pointers...)
\end{description}

However, independently of quality metrics, calling external code is inherently dangerous (Mergendahl \etal\,\cite{mergendahl_cross-language_2022} and Li \etal\,\cite{li_detecting_2022}). Intuitively, calling foreign code that does not present the same guarantees as a safe language should be considered dangerous. But according to the existing literature, simply the fact that our code \textbf{is} multi-language makes it dangerous, independently of which languages are bound together, even if called languages offer many guarantees. It depends on the assumption.

\subsection[A new cross-language paradigm for the programmer]{A new cross-language paradigm for\linebreak[4] the programmer}

Li\,\cite{li_improving_2014} stresses why using \glsxtrshort{FFI} is an error-prone process for the programmer. From the human perspective, it is not only expected to reason in their own language but across different languages. Some differences are straightforward, such as  type system, semantics, and syntax while some are more subtle, such as exceptions or error handling, or memory management. All of a sudden, the programmer needs to understand the nuances and complex inter-connectivity of programming languages, as well as the context that allows the apparition of specific bugs.

In a safe language such as Rust, programmers may misuse the \texttt{unsafe} abilities that are provided to them (Li \etal\,\cite{li_detecting_2022}), while any mistake at the FFI layer may corrupt Rust safety, an issue stressed by Evans \etal\,\cite{evans_is_2020}.

In other words, FFI are challenging, not only when it comes to identifying bug patterns but also in establishing solutions. In addition, programmers (and researchers) must now reason about single-language components in a multi-language context. 
For example, Java programmers tend to avoid reasoning about code interleaving and can consider native methods as black boxes\,\cite{li_improving_2014}. 
The complexity is accrued by the general lack of experience in FFI and the lack of empirical or experimental research. From the programmer and researcher side, it requires keen knowledge and comfort with both the foreign and host languages, in particular within exception and error handling, memory, type system, and thread models, as well as a deep understanding FFI interactions and the 
impact that the technique itself may have during those interactions.  In other words, FFI errors are one of the most significant causes behind memory-safety bugs in existing code bases\,\cite{li_improving_2014, patterson_linking_2017}.

\subsection{Issues from the compiler perspective}

While managing \glsxtrshort{FFI} is challenging from the human perspective, it is also not trivial for a compiler. While writing code, programmers add annotations that are an additional source for the compiler. Richer linking types are beneficial as a source of information\,\cite{patterson_linking_2017}. Mergendahl \etal\,\cite{mergendahl_cross-language_2022} also illustrate how it is inherently unsafe to use FFI in Rust. Even if Rust has rules, such as a warning that the programmer should avoid using dynamically-sized types, it still authorizes sending arbitrary data and pointers across the language barrier.\footnote{This rule is not forcefully implemented. The compiler warns but does not prevent compilation. Sending dynamically-sized data is de facto possible.} 
And when communicating with C, this requires the \texttt{unsafe} keyword, which indicates to the compiler that the programmer is taking responsibility from the compiler to ensure that this part of the code is correct.

Additionally, Mergendahl \etal stress another aspect, namely the difference between intended/unintended interactions. Their work focuses on intended interactions, but they remind us that unintended interactions are also possible within multi-language applications sharing a heap and an address space. In other words, a new class of bugs not yet discovered await the unsuspecting programmer, which the authors leave as future work\,\cite{mergendahl_cross-language_2022}.

\subsection{FFI introduces a new class of bugs}

Bugs introduced by \glsxtrshort{FFI} are not straightforward (Li\,\cite{li_improving_2014}). They are subtle, and the lack of previous experience and tools introduces additional complexity. There is very little empirical or experimental research systematically identifying FFI bugs.\footnote{At the time of writing in 2014, but other authors do not mention a strong body of research.}

On the contrary, Li insists that the search for bug patterns particular to FFI has just begun. This search focuses on a small set of problems that concern a minority of software quality issues --- while some bugs are completely unique. This is also a point confirmed by Mergendahl \etal\,\cite{mergendahl_cross-language_2022}, as well as Li \etal\,\cite{li_detecting_2022}.

Work on Rust FFI is closely related to research done on \glsxtrshort{JNI} (Mergendahl \etal\,\cite{mergendahl_cross-language_2022}). Without entering into too many details unrelated to this thesis, one pattern causing vulnerabilities is the mishandled Java exceptions. At the time of writing (2014), this bug pattern was considered unique (Li\,\cite{li_improving_2014}), but not unique to JNI. This pattern concerned any language which allowed exceptions thrown by native components\,\cite{li_improving_2014}. Rust is known for its rich error handling management (distinguishing recoverable vs. unrecoverable errors, error propagation) and how Rust errors can be propagated to SPARK through FFI is a relevant question in the frame of this thesis. 
\subsection{Cross-Language Attacks}

When going further from \emph{mere} memory unsafety to the actual act of exploitation, Mergendahl \etal\,\cite{mergendahl_cross-language_2022}, emphasize how incompatible assumptions on different sides of the \glsxtrshort{FFI} permit attacks that are impossible in a single language context. The authors mean that the gradual integration of additional safe languages in an unsafe code base, which is assumed to improve the code base safety is in fact a problem. By doing so, the authors add a new vector of attack to the current knowledge on security, the \gls{CLA} vector. They demonstrate that the mere idea of ``incrementally hardening memory unsafe code with memory safe code can have serious flaws—beyond C/C++ hardening bypasses—if not handled properly"\,\cite{mergendahl_cross-language_2022}.

Although Rust and other safe programming languages, such as Go and Swift, are announced as being the best chance for safe software Mergendahl \etal show several examples of how exploitation is possible because of the combination of safe and unsafe languages. Furthermore, since exploitation in unsafe languages without protection are ``trivial"\,\cite{mergendahl_cross-language_2022}, the authors focus on the case where  \glsxtrshort{FFI} is bridging unsafe code with \textit{some} protection, and safe code. 


In Mergendahl \etal model \glsxtrshort{CLA} starts in a safe language (Rust), where memory safety is guaranteed. The control flow is transferred to the unsafe language to proceed to the memory corruption (where hardened C with \gls{CFI} ensures that control-flow hijacking is made impossible). The application transfer back to the safe language to execute the gadget. In summary, the unsafe language assumes [\ldots\ ] hardening (control flow integrity), which prevents control hijacking, while the safe language assumes the program is free of corruption.

The authors insist that their model while focusing on Rust and C++ for simplicity, can generalize to other safe languages. It is natural to wonder how it can generalize between safe languages such as SPARK and Rust. In their conclusions, Mergendahl \etal note that they believe their model applies to Rust and Go. Those two safe languages have different strategies around memory safety --- that is lifetime management and garbage collection. If a system combining both disagree, double frees and use after frees are still possible, which opens the door to other non-obvious vulnerabilities\,\cite{mergendahl_cross-language_2022}.

\Needspace*{6\baselineskip}
Mergendahl \etal successfully illustrate that any FFI established without ``extreme care"\cite{mergendahl_cross-language_2022} can lead to artfully crafted exploits, where the classic control-flow hijacking was impossible before. They show that the thread model for a multi-language application is the ``union of the threat models of the constituent languages"\cite{mergendahl_cross-language_2022}. Does this bring the state of knowledge to the C/C++ level, where the programmer is responsible for securing the program?

\section{Summary}

Ensuring software security can be challenging, even in languages with strong safety guarantees. One reason is that dependencies can introduce potential vulnerabilities, and another reason is that programmers can still call unsafe code. However, the SPARK is formally verified, and the Rust community is actively working towards formal verification as well. Adhering to established guidelines and specifications is the first step to ensuring security.

Multi-language applications with \glsxtrshort{FFI} open new vectors of attacks and resuscitate old vulnerabilities. This is still true when combining two safe languages with different memory assumptions. 
There is ongoing research around FFI, as it is a complicated subject for the programmer and the compiler. In addition, debugging FFI software is a complex and uncharted territory. The most effective tool is static analysis\,\cite{li_improving_2014}, which requires expertise from the programmer.
This reinforces the need for safe guidelines when building multi-language applications.


\cleardoublepage
\chapter[Methods: Control studies and BBQueue]{Methods: Selection process for control studies and\linebreak[4] presentation of the BBQueue library}
\label{ch:methods}

This chapter provides an overview of the research method, control-studies, as well as a high-level overview of the library BBQueue. 

\section{Research Process}
\label{sec:researchProcess}


The research process is constituted of four steps:

\begin{enumerate}[leftmargin=*, label=\textbf{Step \arabic*}, ref=Step \arabic*] %labelindent=1em for indent
    \itemsep0em
    \item \label{x:s1} Preparation: planning the experiments and delimiting the scope, including setting all appropriate tooling and environment for both Rust and SPARK ecosystems,
    \item \label{x:s2} Type selection: choosing data types for control studies,
    \item \label{x:s3} Control studies: perform the control studies, and
    \item \label{x:s4} Application: apply the learning from the control studies in a real-world setting.
\end{enumerate}
Figure~\ref{fig:researchprocess} decomposes the steps to carry on this project.
\FloatBarrier

%https://tex.stackexchange.com/questions/116621/tikz-flow-chart-questions
\begin{figure}[ht!]
    \centering
    \scalebox{0.9}{
    \begin{tikzpicture}
    [node distance=.8cm,
    start chain=going below, %font=\large,
    tuborg/.style={decorate, decoration={brace, amplitude=3pt}, line width=1mm},
    tubnode/.style={midway, right=2pt, align=left, font=\large, text width=4cm, xshift=4mm},
    ]
    % group 1
         \node[punktchain, join, draw=black,fill=color1bg_fill] (lit){Literature study};
         \node[punktchain, join, draw=black,fill=color1bg_fill] (consult){Consultation with experts};
         \node[punktchain, join, draw=black,fill=color1bg_fill] (scope){Scope limitation};  
    % group 2
         \node[punktchain, join, draw=black,fill=color2bg_fill] (typselec){Type selection};
         \node[punktchain, join, draw=black,fill=color2bg_fill] (stats){Statistics};
    % group 3
         \node[punktchain, join, draw=black,fill=color3bg_fill] (cs){Control studies};
         \node[punktchain, join, draw=black,fill=color3bg_fill] (analys){Analysis};   
         \node[punktchain, join, draw=black,fill=color3bg_fill] (memver){Verification of correctness};   
    % group 4
         \node[punktchain, join, draw=black, fill=color4bg_fill] (bbq){BBQueue implementation};
    %% No. 1
    \draw[tuborg, decoration={brace}] let \p1=(lit.north), \p2=(scope.south) in
        ($(3, \y1)$) -- ($(3, \y2)$) node[tubnode] {Preparation};
    %% No. 2
    \draw[tuborg, decoration={brace}] let \p1=(typselec.north), \p2=(stats.south) in
        ($(3, \y1)$) -- ($(3, \y2)$) node[tubnode] {Types selection};
    %% No. 3
    \draw[tuborg, decoration={brace}] let \p1=(cs.north), \p2=(memver.south) in
        ($(3, \y1)$) -- ($(3, \y2)$) node[tubnode] {Control studies};
    %% No. 4
    \draw[tuborg, decoration={brace}] let \p1=(bbq.north), \p2=(bbq.south) in
        ($(3, \y1)$) -- ($(3, \y2)$) node[tubnode] {Real-world \\ implementation};
    \end{tikzpicture}}
  \caption{Research Process}
  \label{fig:researchprocess}
\end{figure}
\FloatBarrier

\clearpage

\section{Research Paradigm}
\label{sec:researchParadigm}

This research adheres to three research paradigms.

First, we employ a hypothesis-driven research paradigm. We believe we can maintain the internal consistency of both Rust and SPARK when both languages are combined, through the establishment of guidelines to combine both languages safely. 

Second, we utilize a qualitative research paradigm, which involves a selection of data types through statistical methods, that enable us to explore safe bindings between the two languages. This methodical approach enhances our understanding of how these languages interact.

Last, we employ the empirical research paradigm. After establishing guidelines  through control studies, we apply said guidelines to a more substantial code base. This stage is a realistic experiment where we anticipate bugs and errors as in any realistic setting. It marks the preliminary stage in achieving reproducibility and generalization of our results.

\section{Choice of data types for control studies}
\label{sec:dataCollection}

The research question raised early in this process is the selection of useful Rust and SPARK types for analysis. 
With the tool described below, we could reply to the preliminary research question and select data types that are stack and heap objects, as well as references/pointers. 

We created a regex counter to analyze 17 Rust code bases (\Cref{sec:systemDocumentation}), including the Rust compiler, and three open-source code bases in SPARK for a total of 1,861 k\gls{LOC}. The selected data types are a series of stack and heap objects, which the Rust and SPARK projects commonly used. The usage of the tool was completed by expert advice.

\subsection{Statistic tool}
\label{sec:stats}


The program, listed in \Cref{sec:systemDocumentation}, counts occurrences of different patterns with Regex in the code bases, including numbers, arrays, references, strings, and various heap-allocated types. The detailed list of regexes used for statistics is available in \Cref{sec:regexes}.

\texttt{cloc 1.9} counted 26,754 Rust files (1,862 k\gls{LOC}) in popular and qualitative Rust repositories. It covered 504 Ada files in open-source SPARK repositories, totaling 27 kLOC.

\subsection{Reliability and validity of the statistics}

The data is collected via file parsing and \texttt{Regex} patterns.\footnote{Using the Regex Rust crate \href{(documentation)}{https://crates.io/crates/regex}.} 

One source of error can be that some data types can appear in comments instead of the code. This results in the counts being potentially higher than the actual numbers; however, a manual inspection of some matches indicates that the extent of numbers in comments is limited, and the numbers are fairly close to the actual occurrences of the counted type.

Another source of error is that while the regex covers the most common cases, they do not cover edge cases.

\subsection{Rust}

Rust is an open-source project with open crates (libraries). To perform the statistics below, we selected the most popular crates on Rust's official pages for crates, \href{https://crates.io/}{crates.io}. 

Those crates are mostly used in the compiler, and for this reason, we selected popular projects on \href{https://lib.rs}{lib.rs} to analyze what programmers are actively using in production.\footnote{Lib.rs utilizes a ranking algorithm that offers more qualitative information than crates.io, filtering away spam and poor-quality projects. 

The crate popularity is measured by downloads, direct and reverse dependencies, the usage trend, quality of README, tests, comments documentation, examples, and whether the crate is actively maintained.}
Thirdly, the compiler (\#\texttt{66a2d62}), with a code base almost 5 times bigger than the two projects above, is also deemed relevant for statistics.

A detailed description of selected packages from \href{https://lib.rs/}{crates.io} and \href{https://lib.rs/}{crates.io} (description, version, total downloads and \gls{LOC}),is available in \Cref{tab:crates_io} and \Cref{tab:lib_rs} respectively. For a numerical count of the types, refer to \Cref{fig:barplottypesrust}.

When looking at types per project, the rust compiler is almost 5 times bigger than crates.io and lib.rs combined. 
lib.rs is 172 k\gls{LOC}, crates.io is 171 kLOC and the compiler is 1,518 kLOC, but the type distribution is similar (\Cref{fig:stackedrust}). 

Numbers dominate the statistics (\Cref{fig:repartitionrust}) followed by references/pointers. This allows us to reply to the subsidiary research question: both numbers and pointers must be tested when binding Rust and SPARK.

\Needspace*{3\baselineskip}
Numbers are \gls{copy-type}, and their size is known at compile time. They are expressive in their type and protected against overflow.\footnote{The compiler warns against risks of overflow.} This confirms that Rust is used as a low-level systems programming language. 

The second most common category is references, \inlinecode{\&mut T} and \inlinecode{\&T}. References are a key element of Rust's ownership system -- to the difference of pointers, references guarantee a valid ``owner" to the data-- and are used in a fourth of the cases. 

\begin{comment}
\pgfplotstableread{
Rust_type crates_io lib_rs rustc
Numbers  44715 22470 305087
Refs 12662 13909 137530
Arrays  329 700 13790
Vec  228 1682 8576
Enum  602 1283 15040
Struct  4704 3646 48955
String  445 1363 18613
}\EXPDATA 

\begin{figure}
    \centering
    \scalebox{0.9}{
    \begin{tikzpicture}
        \begin{axis}[ 
            cycle list name=rustcolors,
            xtick=data,
            symbolic x coords={Numbers,Struct,String,Refs, Arrays,Vec,Enum},
            ybar,
            ymajorgrids=true,
            grid style=dashed,
            ymode=log,
            width=1\textwidth,
            ylabel=Count of types,
            reverse legend=true,
            width=1\textwidth,
            reverse legend=false,
            legend style={draw=none},
            legend image post style={scale=2.0},
            legend style={
                at={(0.5,-0.1)},
            anchor=north,
            %legend columns=-2
            %mark size=20pt,
        },
            ]
          \addplot table [x=Rust_type, y=rustc]{\EXPDATA} ;
          \addplot table [x=Rust_type, y=crates_io]{\EXPDATA} ;
          \addplot table [x=Rust_type, y=lib_rs]{\EXPDATA} ;
        \legend{rustc (1518 kLOC), crates.io (171 kLOC), lib.rs (172 kLOC)}
        \end{axis}  
    \end{tikzpicture}}
\caption{Absolute number of Rust data types per project}
\label{fig:barplottypesrust}
\end{figure}
%https://tex.stackexchange.com/questions/188147/how-to-put-legend-below-the-chart
\clearpage

\end{comment}


\pgfplotstableread{
Label Numbers  Refs  Struct/Enum  Heap  Arrays
cratesio 70.04 19.83 8.31 1.3 0.52
librs 49.26 30.49 10.80 7.92 1.53
rustc 55.01 24.80 11.54 6.16 2.49
}\testdata


\pgfkeys{
    /pgf/number format/.cd,
    fixed,
    fixed zerofill,
    precision=2
}
\begin{figure}[ht!]
    \centering
    \scalebox{0.9}{
    \begin{tikzpicture}
    \begin{axis}[
        ybar stacked,
        %reverse legend,
        reverse legend=false,
        %https://tex.stackexchange.com/questions/88892/pgfplots-bar-plot-spacing-inbetween-bars
        enlarge x limits=0.4,
	    bar width=45pt,
        /pgfplots/nodes near coords*/.append style={
        every node near coord/.style={
            color=black,
            font=\small,
            name=X,
%            shift={    
%                (50pt,25pt)
%                },
            xshift={50pt},
                yshift ={
                ifthenelse((\plotnum == 4), 30pt,20pt)},
            },
            scatter/@post marker code/.append code={
                \node(Y){};
                \draw(X)--(Y.center);
            }
        },
	    nodes near coords,
        bar shift=5pt,
        ymin=0,
        ymax=115,
        xtick=data,
        width=1\textwidth,
        legend style={draw=none},
        legend image post style={scale=2.0},
        legend style={
            at={(0.5,-0.2)},
            anchor=north,
            legend columns=-2,
            font=\large,
            %mark size=20pt,
        },
        ylabel=Percentage points (\%),
        xticklabels from table={\testdata}{Label},
        xticklabel style={rotate=30},
    ]
    \addplot  table [y=Numbers, meta=Label, x expr=\coordindex] {\testdata};
    \addlegendentry{Numbers}
    \addplot table [y=Refs, meta=Label, x expr=\coordindex] {\testdata};
    \addlegendentry{Refs}
    \addplot  table [y=Struct/Enum, meta=Label, x expr=\coordindex] {\testdata};
    \addlegendentry{Struct/Enum}
    \addplot  table [y=Heap, meta=Label, x expr=\coordindex] {\testdata};
    \addlegendentry{Heap}
    \addplot  table [y=Arrays, meta=Label, x expr=\coordindex] {\testdata};
    \addlegendentry{Arrays}
    \end{axis}
    \end{tikzpicture}}
\caption{Rust types distribution for the compiler, crates.io, and lib.rs
(percentage)}
\label{fig:stackedrust}
\end{figure}


\makeatletter
\let\stripatpt\strip@pt
\makeatother

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{
    \begin{tikzpicture}[scale=3]
    \centering    
     
    \newlength\lena
    \newlength\lenb
      {black,fill=gray,mark=none}
    \foreach \p/\t/\pat\c in {56.06/Numbers/crosshatch/color1bg_dark_fill, 24.71/Refs/vertical lines/color2bg_dark_fill, 11.18/Struct\&Enum/grid/color3bg_dark_fill, 8.05/others (heap)/horizontal lines/color4bg_dark_fill}
       {
        \global\lena=\lenb
        \global\lenb=\dimexpr\lenb+\dimexpr\p pt\relax
        \edef\numbera{\stripatpt\lena}
        \edef\numberb{\stripatpt\lenb}
        \slice{\numbera/100*360}
              {\numberb/100*360}
              {\p\%}{\t}
              {\pat}
              {\c}
              %{\pattern}
              %{black!\p}
      }
    \end{tikzpicture}}
  \caption{Rust types distribution}
  \label{fig:repartitionrust}
\end{figure}
\FloatBarrier

\subsection{SPARK}

Most SPARK large code bases are proprietary. It is therefore difficult to run statistics on a representative code base. From expert opinion (Moy, in direct conversation) and our statistics, similar types to Rust types are appropriate for the control studies, as SPARK and Rust are used in similar contexts.

The statistics are made on three open-source repositories. 
We checked a total number of 504 files and a total of 27 k\gls{LOC}.

\begin{itemize}
    \item \textbf{SPARKNaCl}, with 8,546 \gls{LOC} (git hash \#\texttt{dfb1bd1}). SPARKNaCl is a cryptography library that implements the same functionality as NaCl (a networking crypto library), which aims to provide a completely automated static proof of type safety.
    \item \textbf{EwoK}, with 12,755 LOC (git hash \#\texttt{ca8e2a0}). Ewok is a secure micro-kernel designed for micro-controllers and embedded systems that enforces strict isolation between tasks and device drivers and provides strong access control to physical resources.  
    \item \textbf{SPARK by example}, with 6,485 LOC (git hash \#\texttt{2e4eb5a}). This a repository with exercises to practice the language
\end{itemize}

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{
    \begin{tikzpicture}[scale=3]
    \centering    
    \foreach \p/\t\pat\c in {58.69/Numbers/crosshatch/color1bg_dark_fill, 27.78/Access/vertical lines/color2bg_dark_fill, 12.65/Record\&Enum/grid/color3bg_dark_fill, 0.88/others (0.88\%)/crosshatch/color4bg_dark_fill}   
      {
       \pgfmathtruncatemacro\intp{\p}
    
        \global\lena=\lenb
        \global\lenb=\dimexpr\lenb+\dimexpr\p pt\relax
    
        \edef\numbera{\stripatpt\lena}
        \edef\numberb{\stripatpt\lenb}
    
        \ifthenelse{\intp<2}{
        \slice{\numbera/100*360}
              {\numberb/100*360}
              {}{\t}
              {\pat}
              {\c}
       }{
        \slice{\numbera/100*360}
              {\numberb/100*360}
              {\p\%}{\t}
              {\pat}
              {\c}
        }
      }
    \end{tikzpicture}}
  \caption{SPARK types distribution}
  \label{fig:repartition_spark}
\end{figure}
\FloatBarrier



\section[Experimental design/Planned Measurements]{Experimental design and\\Planned Measurements}
\label{sec:experimentalDesign}
%\todo[inline]{Add some text here to introduce the subsections - there should always be text between any pair of headings.}

This part covers the conclusion to the control studies and threat to validity.
\subsection{Chosen data types}
The control studies are centered around:
\begin{itemize}
    \item Stack objects and scalars: numbers, arrays, enums, and structs (with objects size known at compile time).
    \item Heap objects: dynamic types such as Vec. They require more care during transfer.
    \item References and pointers, with a focus on how ownership is kept or transmitted ownership.
\end{itemize}
\subsection{Threat to the validity of the statistics}

We do not foresee large threats to statistical validity for Rust. Rust is a systems programming language and appears to be used as such. The most significant threat to the validity of the statistics concerns the experiments on SPARK. Large SPARK code bases are proprietary, forcing us to apply statistical analysis on small \gls{OSS} projects. As a counterpoint, we can rely here on expert opinion on how SPARK code is used in real projects (Moy, in direct conversation). SPARK has a long industrial track record, and it is widely used in many industrial applications, including air traffic, avionics, railways \etc. It is based on Ada, which is a general-purpose, stack-based language. Being used in industrial applications, one can safely assume that high-effectivity is a concern of SPARK programmers\,\cite{chapman_adacore_2018}.

\section[BBQueue]{Application with BBQueue}
\label{sec:methodBBQueue}

After finishing the control studies, we moved on to BBQueue to perform a realistic experiment. This section will present this library.

\subsection{High-level overview}
BBQueue is a bipartite circular buffer that allows for contiguous data writes. It is designed for communication between two concurrent threads of control, such as in embedded systems or device drivers. It is particularly adapted for elements of different sizes and streams and allows partial commits and releases.

BBQueue is particularly useful for \glsxtrfull{DMA} in embedded microcontroller systems with memory-mapped peripherals. DMA allows hardware to directly read from or write to memory, minimizing the time needed for the CPU to copy data. This allows efficient data transfer and frees the CPU to execute other tasks or enter sleep mode, saving energy.

This structure is often used when a producer and consumer process must communicate with each other, and this is why the Rust implementation has wrappers in the form of Producer/Consumer. While the SPARK implementation does not use those wrappers, the underlying logic is the same.

BBQueue uses Write and Read grants to communicate in Rust and SPARK implementation. A grant is a
privileged way to access the inner buffer to make communication safe, as the grant engages atomic operations in a precise order. 

\begin{table}[ht!]
\footnotesize
\centering
\caption[BBQueue structure]{BBQueue structure: Producer-Consumer separation exists only in Rust}
\label{tab:bbqueue}
\begin{tabular}{ |m{5cm}|m{5cm}| }
\hline
\rowcolor{color1bg_fill}
\multicolumn{2}{|c|}{BBQueue} \\
\hline
\rowcolor{color1bg_fill}
\centering Producer (only in Rust) & \centering Consumer (only in Rust) \tabularnewline
\hline
1. \textbf{Grant} \newline Gives space to write bytes. Space is guaranteed to have single ownership and be continuous in memory. & 3. \textbf{Read} \newline Gives a mutable slice to read (continuous in memory), but the custom use is an immutable read. \tabularnewline
\hline
2. \textbf{Commit} \newline Makes memory available to read. & 4. \textbf{Release} \newline Frees the memory and gives the space back. \tabularnewline
\hline
\end{tabular}
\end{table}
\FloatBarrier
For our experiments, it is important to note that all communications with the queue go through the Read and Write grants, and the header remains protected from direct interaction. 

\begin{figure}[ht!]
  \centering 
\includesvg[inkscapelatex=false, scale=0.6]{figures/figuressvg/bbqueuelogic.svg}
\caption{Communication flow in BBQueue}
\end{figure}
\FloatBarrier

\subsection{Algorithm}

BBQueue is a BipBuffer, a circular buffer commonly used in embedded systems. It ensures that data is written continuously to avoid fractioning. This makes it an ideal candidate for our real-life implementation as we are guaranteed by both Rust and SPARK implementations that the data will be assigned in a continuous manner.

The data structure uses pointers that simulate a circular buffer connected end to end, even if the underlying buffer is a fixed size buffer of size N (decided by the user.)  

It has a series of atomic pointers for both safety and efficiency. Atomic variables ensure thread safety and permit concurrency, as two threads should never access the same memory chunks at the same time. The atomic pointers track where data should be written and where it should be read from. It also has extra pointers for inverted conditions (when the write mark is before the read), and a watermark to ensure continuity of the written data (making the queue wrap around if there is not enough space at the end of the buffer).  The write operation is in charge of write and watermark pointers, and the read operation is in charge of the read pointer. It also has atomic variables to indicate read/write in progress, returning errors to be handled. More information is available from the authors' respective blogs ~\cite{chouteau_rust_2021, munns_design_2019}.

\section{Summary}

This chapter presented the selection of types and the libraries on which statistics are carried on. In addition, this chapter contains a high-level presentation of the BBQueue library and its algorithm.

\cleardoublepage
\chapter{Experiments}
\label{ch:whatYouDid}

\section{Presentation of experiments}

This section describes both control studies and the real-world implementation with BBQueue, intending to provide recommendations for FFI bindings between Rust and SPARK. The experiments are listed in \Cref{tab:listexperiments}
and the code is available on Github:
\label{sec:systemDocumentation}
\begin{itemize}
    \item Control studies and BBqueue experiments: 
        \url{https://github.com/Dajamante/ada_rust_programs}.
    \item Statistic tool : 
        \url{https://github.com/Dajamante/stat_ada_rust_code}.
    \item SPARK BBQueue 
        \url{https://github.com/Fabien-Chouteau/bbqueue-spark}.
    \item Official Rust BBQueue 
        \url{https://github.com/jamesmunns/bbqueue}
    \item FFI safe Rust BBQueue
        \url{https://github.com/tosc-rs/mnemos/tree/main/source/abi/src/bbqueue_ipc}.
\end{itemize}


\section{List and description of experiments}
\label{tab:listexperiments}

\Cref{tab:fromsparktorust} (9 experiments) and \Cref{tab:fromrusttospark} (8 experiments) show the control studies from SPARK to Rust and from Rust to SPARK,
respectively. The last column describes what behavior we are testing. Similar functionality has the same name (adder, swap/swapper, array\_sender). The tables are not symmetrical as some behaviors could be tested for both languages in one example, and the experiment in the other language is used to either delve deeper or test a variation (passing enums instead of integers, trying another faulty behavior).

The experiment in BBQueue gathers the lessons learned from control studies. \Cref{sec:experimentstack} summarize the experiments goals for stack-allocated types, and \Cref{sec:experimentsheap} covers the heap-allocated types.

\begin{table}[ht!]
\footnotesize
\centering
\caption{Experiments from SPARK to Rust}
\label{tab:fromsparktorust}
\begin{tabular}{ |p{3cm}|p{4cm}|p{7cm}| }
\hline
\rowcolor{color1bg_fill}
%\multicolumn{3}{|c|}{\centering From SPARK to Rust} \\
\hline
\rowcolor{color2bg_fill}
\centering Name & \centering Description & \centering Test, Issue or Question(s) addressed \tabularnewline
\hline
adder\_ada & Sending and reading \texttt{Integer}s & Sending and accessing scalar types by copy and reference. \newline Verifying if the \texttt{in out} parameter annotation can be used to pass objects by reference in \glsxtrshort{FFI} as in a usual SPARK/Ada subprogram \tabularnewline
\hline
swap\_ada & Swapping \texttt{in out Integer}s by reference & Sending, accessing and manipulating simple data types by reference, using \texttt{in out} (as opposed to the \texttt{access} type) \tabularnewline
\hline
array\_sender & Iteration through an \texttt{Integer} array  & Iterating through a composite type of known size at compile time. \newline Triggering compiler error by going out of bounds (OOB). \newline Introducing sanitizers \texttt{-Z sanitizer=address} on the Rust and \texttt{ -fsanitize=address} on SPARK side to test for undefined behavior. \tabularnewline
\hline
fat\_pointer & Sending and accessing composite data type (\texttt{Struct} with \texttt{String} and \texttt{Integer}) & Reconstructing a composite datatype, using layout information provided by the compiler. \tabularnewline
\hline
print\_enum & Sending and accessing \texttt{enum}s with a given size & Verifying \texttt{enum}s behave as expected (as \gls{copy-type}). \newline Comparing Rust's \texttt{\#[repr(u8)]} and SPARK \texttt{Size => 8}. \tabularnewline
\hline
fat\_pointer\_overwrite & As above, sending and accessing composite data type and writing over the sent \texttt{String} & Same as above, but with additional implementation of separation of concerns between pointer logic (\glsxtrshort{FFI} side hidden from user) and business logic (user side) \tabularnewline
\hline
mem\_violation & Passing created \texttt{String} type and reading OOB & Verifying what happens with error unwinding across the FFI border. \tabularnewline
\hline
panics & Calling explicitly a Rust \texttt{panic!()} & Same as above. \tabularnewline
\hline
p pointer & Passing non-anonymous access type to a \texttt{Struct} with two \texttt{Integer} and increment both fields & Working with \texttt{access} types: verify that non-anonymous pointers can be passed and received in Rust as references, and study the behavior of anonymous access types. \tabularnewline
\hline
\end{tabular}
\end{table}
\FloatBarrier


\begin{table}[ht!]
\footnotesize
\centering
\caption{Experiments from Rust to SPARK}
\label{tab:fromrusttospark}
\begin{tabular}{ |p{3cm}|p{4cm}|p{7cm}| }
\hline
\rowcolor{color1bg_fill}
%\multicolumn{3}{|c|}{\centering From SPARK to Rust} \\
\hline
\rowcolor{color2bg_fill}
\centering Name & \centering Description & \centering Test or Issue addressed \tabularnewline
\hline
num\_swapper & Swapping \texttt{Integer}s sent by copy & Accessing and manipulating simple data types by copy. \tabularnewline
\hline
ada\_adder & Sending and reading \texttt{Integers} by copy and reference & Sending and accessing scalar types, both by copy and reference, to be read or incremented. This experiment is also used to analyze the compiler's behavior with miri.\footnote{\href{https://github.com/rust-lang/miri/}{miri} is an interpreter for mid-level intermediate representation (MIR) for the rust language. It tests certain types of undefined behavior. It is not available for pure FFI projects.} \tabularnewline
\hline
ada\_divider & Passing \texttt{Integer}s by copy \& testing undefined behavior & Manipulating \texttt{Integer}s and returning a new copy object. \newline Testing undefined behavior and unwinding a program at the FFI border. \tabularnewline
\hline
enum\_sender & Sending and accessing \texttt{enum}s with fixed size & Verifying \texttt{enum}s behave as expected (as \gls{copy-type}). \newline Verify enums can be reconstructed on the other side of the FFI frontier \newline Comparing \texttt{\#[repr(u8)]} and \texttt{Size => 8}. \tabularnewline
\hline
array\_sender & Iteration through a \texttt{char} array & Iterating through a type for which size is known at compile time and verify it behaves as expected. The chosen array type is bounded String. \tabularnewline
\hline
ada\_forbidden\_mem & Sending \texttt{String} dynamically allocated in different regions and trying to recover the object on the Rust side & Understanding where non-anonymous/anonymous access types are allocated in SPARK and what kind of memory pointers are possible to pass.\tabularnewline
\hline
num\_allocator & Allocating and deleting \texttt{Integer}s on the heap in SPARK & Managing heap allocated memory according to good FFI citizen principles. Writing appropriate allocation and deallocation functions. \tabularnewline
\hline
ada\_string\_overwriter & Sending and accessing String created in SPARK, with deallocation managed according to the good FFI citizen principle & Same as above, with some additions: separation of concerns between pointer and user data, and implementing traits that are found in the original Rust String \tabularnewline
\hline
\end{tabular}
\end{table}
\FloatBarrier



\section{Experiments on stack-types}
\label{sec:experimentstack}
Stack types cover scalar and aggregate types.\footnote{A scalar type is a type that can hold a single value at a time (\texttt{Integer, Float, enum...}). Conversely, a non-scalar type holds different values (\texttt{array...}).} Scalar types include Integer and arithmetic manipulations (by value and references). Non-scalar types include arrays, structs, and fieldless enums where the focus is on achieving compatibility. Errors are also explored.

Those experiments demonstrated how to perform sound and safe operations with stack-allocated data using \gls{FFI}
as well as best practices for memory safety and type safety. Ownership is usually not a concern as simple types are \gls{copy-type}.
Potential issues are highlighted. 
The experiments cover:

\begin{itemize}
    \item passing integers by reference and by copy, demonstrating type safety and memory safety as well as memory leaks;
    \item passing composite types with different sizes,
    \item passing an aggregate type (array) to a foreign function to calculate a sum, illustrating possible memory errors;
    \item passing an aggregate type to a foreign function to demonstrate the use of \texttt{\#[repr()]} attributes for FFI-safety;
    \item allocating and deallocating memory through FFI, following the "good FFI citizen principles"~\cite{gjengset_rust_2021}: memory must be freed by the appropriate allocator; 
    \item testing for various memory violations and undefined behavior, demonstrating how the guarantees offered by safe languages no longer hold.
\end{itemize}
 
\section{Experiments on heap types}
\label{sec:experimentsheap}

The heap-types experiments focus on more complex memory management scenarios, emphasizing representing heterogeneous data correctly, meeting layout expectations, and writing to specific locations.
%, such as replacing bytes inside a String
These experiments demonstrate how to perform safe operations with heap-allocated data while minimizing unsafe code and delegating the operations to the language semantics --- such as built-in ownership management, or separation of concerns between the language logic and the FFI logic.

The experiments cover:

\begin{itemize}
    \item Defining structs to hold complex and nested data types, respecting their layout and alignment;
    \item Implementing methods/traits for creating, accessing, and modifying complex data types;
    \item Implementing method/traits for dereferencing and dropping memory after usage;
    \item Minimizing unsafe code: while still not focusing on defensive code, the unsafe operations are exported to a part of the code where those operations could be delegated to the language semantics.   
\end{itemize}


%We run \texttt{valgrind} to show both sound bindings and bindings which have intentional memory leaks, as a demonstration.


\section{BBQueue}

The BBQueue experiments consisted in testing the ``lesson learned" from the control study to understand and model more complex data structures. The work is divided into smaller steps. Firstly, we looked at data structures and algorithm implementations on both Rust and SPARK sides. Secondly, we tested the Rust official version of BBQueue for single-threading and multi-threading usage. Thirdly, we switched to the unofficial, FFI-safe, bbqueue\_ipc implementation, modifying stack-allocated data. 
Finally, we proceeded to the \glsxtrshort{FFI} implementation with SPARK.

The operations on BBQueue covered the following:
\begin{itemize}
    \item Modeling and defining wrapping types to hold nested data types;
    \item Implementing methods for sending and accessing complex data types through the \glsxtrshort{FFI} border;
    \item Verifying for type safety (by creating appropriate types), memory safety (with valgrind), and ownership (through documentation and manual analysis).
\end{itemize}

\section{Additional tools for debugging and tracking memory usage}

To assess memory safety, we use \texttt{valgrind} and \texttt{Rust-san}.\footnote{\url{https://github.com/japaric/rust-san}}
When possible, we used \texttt{GNATprove} and \texttt{miri}, even if the tools are not designed for FFI. The prover can only cover SPARK code, not external code, and \texttt{miri} is still limited for FFI.

Other tools considered: \texttt{FFI-checker}~\cite{li_detecting_2022}, \texttt{rr}\footnote{\url{https://rr-project.org/}} and \texttt{memflow}\footnote{\url{https://github.com/memflow/memflow}} but \texttt{valgrind} is sufficient, as the memory we analyzed is local, and there is no need to track allocation at the \glsxtrshort{OS} level.
For some types that are \gls{copy-type}, we used graph generators to visualize the control flow. \texttt{objdump} provide information on which areas of memory are causing errors when accessed.



\section{Summary}

This chapter presents the experiments carried out as control studies, as well as the behaviors studied for data structures allocated on the stack or heap. This chapter also summarizes the process when working with BBQueue, a more complex library representing a Bip-Buffer described in \Cref{sec:methodBBQueue}.

\cleardoublepage
\chapter{Results and Analysis}
\label{ch:resultsAndAnalysis}

The experiments help provide recommendations and insights for creating automated binding tools. SPARK and Rust are languages semantically richer than C, so we must preserve type safety and ownership. Manual bindings in those experiments allow full control over layout and alignment to explore safety issues. The compiler behavior is critical, we recommend using the GNAT compiler. The most salient points for stack and heap types are summarized in respectively \Cref{stack-types-behavior} and \Cref{heap-types-behavior}.

\section{Behavior of stack types: summary and takeaways}
\label{stack-types-behavior}

Regarding type safety for stack types, the issues encountered can mostly be addressed by identifying the appropriate types and ensuring their size and alignment is correct. As for the process of passing and modifying by reference or pointers, it can be implemented seamlessly by using respectively \texttt{\&mut T}, \texttt{\&T}, and \texttt{Box} on the Rust side, and \texttt{in out} on the Spark side. Working with stack types is more straightforward than processing heap types, as the latter introduces additional complexity and restricts the ability to take advantage of the compiler's safety mechanics.

The challenges regarding type selection can be resolved from the existing documentation (language and compiler), creating/importing a new type with the desired behavior (such as a modular type that is \href{https://ada-lang.io/docs/arm/AA-3/AA-3.5#354--integer-types}{built-in in Ada/SPARK} but requires a library in Rust) or by creating an appropriate zero-sized wrapper type for nested types. 

\Needspace*{4\baselineskip}
Finding the information in the documentation requires attention to detail as information is platform and compiler dependent. For example, \texttt{Integer}s are very specific, and the \texttt{char} type resolves to \texttt{i8} or \texttt{u8} depending on the platform.\footnote{\url{https://github.com/search?q=repo\%3Arust-lang\%2Flibc\%20c_char&type=code}}

%\href{platform}}

For Ada/SPARK, it is more nuanced as the compiler chooses to pass the data as it sees fit. Even if passing by copy did not prove to be an issue (with the pragma \texttt{pass\_by\_copy}\footnote{GNAT documentation, p33: 
\url{https://docs.adacore.com/live/wave/gnat_rm/pdf/gnat_rm/gnat_rm.pdf}.}) it is recommended to follow the C convention and pass by reference when bridging the two languages. It guarantees a behavior similar to C, which is \href{https://en.wikibooks.org/wiki/Ada_Programming/Types/access}{predictable}.

In general, both Rust and SPARK are well-behaved and predictable when it comes to \gls{copy-type}.
Memory safety and ownership do not pose any issues. Copy types are effectively managed by the compiler, thereby eliminating any potential issues. 


\subsection{Numbers}
\label{sec:numbers}
Manipulating numbers is straightforward as they merely require the appropriate data type. They can be passed by copy or reference, and ownership is not an issue as the compiler cleans memory for any \gls{copy-type} type.

Consistency must be ensured between Rust and Ada/SPARK types: Rust types are explicit about their size (e.g., \texttt{u64, i32}). Corresponding Ada/SPARK types must be the same size to avoid errors or unexpected results, such as garbage being read around the memory block passed. For SPARK, the necessary information is found in the language and compiler documentation.\footnote{GNAT compiler documentation: \url{https://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/implementation_defined_characteristics.html}.}
For instance, the GNAT reference manual states that the Integer type in Ada/SPARK is 32-bit signed, which corresponds to \texttt{i32} in Rust. This is not necessarily true if using another compiler or another platform.

Additionally, the programmer should avoid machine-dependent types when they are unnecessary: types like \texttt{usize} and \texttt{isize} in Rust are machine-dependent and should be used for indexing. When interfacing with SPARK, these types should be replaced with appropriate, non-machine-dependent counterparts to ensure platform compatibility.

\subsection{Enums}

The primitive representations of fieldless enums set the size and alignment to be the same as the primitive type of the same name. \texttt{\#[repr(C)]} will guarantee the same layout as expected from C, but \texttt{\#[repr(u*)]}, with \texttt{u*} being a primitive integer type whose layout is to be used, is also possible. All variants will be resolved to a tag (an integer). The enum must be reconstructed on the other side and can be accessed.
\begin{comment}
    \begin{minted}{rust}
#[repr(u8)] 
enum TwoEnum {
    One,
    Two,
}  
\end{minted}

\begin{minted}{ada}
type TwoEnum is (One, Two);
\end{minted}
\end{comment}


\subsection{Arrays}

Sized arrays can be passed by copy or reference. The size of the elements must be indicated on the side receiving the object, as described in \Cref{sec:numbers}. Particular care is necessary when validating the bounds, as negligence/error can lead to the introduction of undefined behavior as per \Cref{sec:undefinied-behavior}.

\section{Behavior of heap types: summary and takeaways}
\label{heap-types-behavior}

Regarding type safety, the issues encountered can be resolved by identifying the correct data types from the documentation as per the previous section on stack types in \Cref{stack-types-behavior}. 

However, the matter of memory safety is a bit more intricate. Both the Rust and Spark compilers have their memory safety mechanisms, but these safeguards fail at the \gls{FFI} border, as this is not what those mechanisms are there for --- they assume a single language. In the case of non-\gls{copy-type} types, the borrow-checker Rust borrow checker becomes unusable, and using references to existing objects is unsuitable. This is similar to Mergendahl \etal findings \cite{mergendahl_cross-language_2022}.

Instead, it is necessary to work with raw pointers to ensure ownership is transferred correctly. Nevertheless, some language guarantees can be maintained by separating pointer logic from language logic. Additionally, it is crucial to minimize the unsafe parts to limited parts of the code~\cite{miller_step_2018}, preferably in the type definition. For a detailed example, please refer to \Cref{ch:separation_of_concerns}.
%\todoinline{a comment! I find this example very interesting because it is covering a lot of findings but it is more detailed for this part, too much language specifics}
As we default to raw pointers, we must adhere to good FFI citizen principles for ownership concerns~\cite{gjengset_rust_2021, miller_step_2018}. 

It is worth noting that Rust's borrowing behavior is both more flexible and complex compared to Spark's more restrictive approach. SPARK does not use lifetimes and all information about borrowing/observing must be statically known~\cite{moy_proof_2019}. For instance, Spark assumes ownership of an entire array when it is passed to a function, which prohibits receiving Rust's slicing of the same array in the same function. 
On the other hand, memory management is more opaque in Rust than in SPARK. SPARK allows the creation of `storage pools "for object allocation in memory --- a feature that exists in Rust but is still unstable at the time of writing.\footnote{std::alloc::Allocator: \url{https://doc.rust-lang.org/std/alloc/trait.Allocator.html}.} 

Although this allows SPARK to make more guarantees and fine-grained control of memory, we must default to the more restrictive model when bridging the two languages. 

Even though control studies and experiments with the BBQueue library have shown successful outcomes with the default storage pool and heap, we recommend deferring to the more restrictive model in a more complex experiment, for the sake of consistency and caution.

\subsection{Fat pointers}

Ada/SPARK access types and Rust references are fat pointers.\footnote{Fat pointers are composed of two elements, the pointer itself and metadata such as the length of the element or boundaries.} They carry more information and have more assumptions than in the C language. This information must be conveyed appropriately throughout the FFI barrier. In those experiments, memory allocation for heap types is not an issue as both Rust~\cite{santos_investigating_2022} and SPARK are using \texttt{malloc} on x86\_64. This is platform dependent, has changed historically, and it is not guaranteed it will remain true.\footnote{Rust had jemalloc: \url{https://internals.rust-lang.org/t/jemalloc-was-just-removed-from-the-standard-library/8759}.} 
This must be kept in mind while implementing an automated tool. However, anonymous access types are considered local and end up in memory regions inaccessible to \gls{FFI}. To perform cross-language operations, the SPARK access types must be named.

\subsection{Receiving and reading fat pointers}
\label{sec:receiving-fat-pointers}
We use the \texttt{String} type to carry out a demonstration, which is complex in both SPARK and Rust. With the \texttt{String} type, we represent all the information carried by the fat pointer and how to rely on the language semantics to ensure all the security operations "for free".

\begin{figure}[ht!]
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}
    [node distance=.8cm,
    start chain=going right,
    tuborg/.style={decorate, decoration={brace, amplitude=3pt}, line width=1mm},
    tubnode/.style={midway, right=2pt, align=left, font=\large, text width=4cm, xshift=4mm},
    ]         \node[punktchain, join, draw=black,fill=color1bg_fill] (string){Vec<u8> of UTF-8};  
    % group 2
    \node[punktchain, join, draw=black,fill=color2bg_fill] (vec){Vec<T>};
    \node[punktchain, join, draw=black,fill=color3bg_fill] (rawvec){RawVec<T>};
    \end{tikzpicture}}
  \caption{Rust String, built on three different internal types}
  \label{fig:ruststring}
\end{figure}
\FloatBarrier

\begin{figure}[ht!]
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}
	\node [draw, rectangle, fill=color1bg_fill, minimum width=1cm, minimum height=1cm] (box1) at (0,0) {first};
	\node [draw, rectangle, fill=color1bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box1] (box2) {last};
	\node [draw, rectangle, fill=color2bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box2] (box3) {'h'};
	\node [draw, rectangle, fill=color2bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box3] (box4) {'e'};
	\node [draw, rectangle, fill=color2bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box4] (box5) {'l'};
	\node [draw, rectangle, fill=color2bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box5] (box6) {'l'};
	\node [draw, rectangle, fill=color2bg_fill, minimum width=1cm, minimum height=1cm, right=0cm of box6] (box7) {'o'};
 	\draw [decorate, decoration={brace, mirror, amplitude=10pt}] (box1.south west) -- (box2.south east) node [midway, below=12pt] {Bounds (discrete type)};
    \end{tikzpicture}
 }
  \caption[Ada/SPARK unconstrained String]{Ada/SPARK unconstrained String: it is a pointer to bounds and an array. Any discrete type can index the bounds.}
  \label{fig:sparkstring}
\end{figure}
\FloatBarrier
Both sides need to reconstruct the String type. For Ada, the documentation informs that values of unconstrained arrays (which an unconstrained String array is) types store the bounds ahead of the value. However, we are guaranteed by the documentation that the language will pass the address of the first component.{\footnote{Documentation link : \url{https://learn.adacore.com/courses/intro-to-embedded-sys-prog/chapters/multi\_language\_development.html}.} Since we know what the internal representation looks like, we can model the String in Rust while passing a SPARK String.

\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{rust}
#[repr(C)]
pub struct AdaBounds {
    first: i32,
    last: i32,
}
#[repr(C)]
pub struct AdaString {
    // internal memory allocation that must follow Ada convention
    data: *mut u8,
    bounds: *const AdaBounds,
}
\end{minted}
\caption[Reconstructed Ada String]{Reconstructed Ada String}
\label{lst:reconstructed_ada_string}
\end{listing}
%\FloatBarrier


From Rust, the approach is somewhat different. A Rust string is not \texttt{\#[repr(C)]} (having the same representation as expected in C), which implies that the compiler can rearrange the data structure as it sees fit. It is not \gls{FFI}-safe and as such, should not be sent to SPARK. \footnote{As a reminder, any data structure that is not tagged \texttt{\#[repr(C)]} cannot be passed safely through FFI: this tag requires the compiler to arrange the data type as C would expect.} In the first step, we need to break down the structure to expose its inner fields in \Cref{lst:deconstructed_rust_string} and tag the data structure with \#[repr(C)]. In a second step, since Rust memory is managed with ownership, Rust must "forget"\footnote{The procedure of forgetting is to request the compiler not to deallocate that memory, and let the programmer take responsibility for deallocating it.} the string and to avoid dropping its memory when the owner variable goes out of scope. This means concretely that for this experiment the programmer gets around the safety guarantees and prevents the language from following its safety design. 

As a consequence, the language guarantee must be re-implemented by the programmer or an automated tool following this process. 
In the third step, the data structure must be reconstructed on the SPARK side \Cref{lst:reconstructed_rust_string}, with the right types and layout.


\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{rust}
#[repr(C)]
struct RustFFIString {
    ptr: *mut c_char,
    len: usize,
    cap: usize,
}

impl RustFFIString {
    fn from_string(s: String) -> Self {
        let raw_str = RustFFIString {
            ptr: s.as_ptr() as *mut c_char,
            len: s.len(),
            cap: s.capacity(),
        };
        // forgetting allows the language to not drop 
        // the object when it goes out of scope
        std::mem::forget(s);
        // returning the object
        raw_str
    }
}

\end{minted}
\caption[Deconstructed Rust String]{Deconstructed Rust String}
\label{lst:deconstructed_rust_string}
\end{listing}
\FloatBarrier

\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{ada}
type Rust_String is record
    ptr : System.Address;
    len : Interfaces.Unsigned_64;
    cap : Interfaces.Unsigned_64;
  end record;
  -- Forcing the compiler to treatr objects by reference
  pragma Convention (Ada_Pass_By_Reference, Rust_String);
end record;
\end{minted}
\caption[Reconstructed Rust String]{Reconstructed Rust String in SPARK}
\label{lst:reconstructed_rust_string}
\end{listing}
\FloatBarrier

Again, getting the types right is critical. It is unfortunate to be unable to rely on \texttt{\&mut T} type, despite the guarantees offered by the compiler (single ownership, no aliasing). \texttt{\&mut T} and \texttt{\&T} should be used in a very limited scope and avoided when bridging two languages, as the lifetime guarantees from the Rust compiler cover only Rust. 

In other words, borrowing is a short-term solution and should not be passed across FFI borders. Instead, the following design \Cref{tab:stringlogic} is more appropriate, with a Rust-like string facing the user and a private String with unique pointers that manage communication across the FFI border. For a detailed example, refer to \Cref{ch:separation_of_concerns}.
This can be generalized for most heap objects.


\begin{table}[ht!]
\footnotesize
\centering
\caption{FFI Heap object logic (String)}
\label{tab:ffistringlogic}
\begin{tabular}{ |>{\raggedright\arraybackslash}m{5cm}|>{\raggedright\arraybackslash}m{5cm}| }
\hline
\rowcolor{color1bg_fill}
\multicolumn{1}{|>{\centering\arraybackslash}m{5cm}|}{pub String} &
\multicolumn{1}{>{\centering\arraybackslash}m{5cm}|}{priv String} \\
%pub String & priv String \\
\hline
1. Unique \newline 2. Can be borrowed \newline 3. Must implement language memory guarantees & 1. Fat pointer with data and bounds \newline 2. Hidden from the user \newline 3. Memory management relies on the programmer \\
\hline
\end{tabular}
\label{tab:stringlogic}
\end{table}
\FloatBarrier



\subsection{Composite types}
\label{sec:compositetypes} 

We found that both Rust and SPARK objects are "well-behaved" in the sense that they  are designed to interact with C and the outcome is predictable (the objects must be tagged accordingly). However, composite objects need closer examination as the layout needs sometimes to be adjusted manually.
GNAT has a series of flags that allow to visualize an object in memory and adjust the Rust object accordingly, such as \inlinecode{-gnatRe2}.\footnote{Debugging control: \url{https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/building_executable_programs_with_gnat.html}.} Using it on a composite object will give an output similar to \Cref{lst:gnatrj}.

\begin{listing}[!ht]
\begin{minted}[
%frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
%linenos
]{ada}
type Record_String_Int is record
    S : access String;
    I : Integer;
    B : Boolean;
end record;
\end{minted}
\label{lst:composite}
\end{listing}
\FloatBarrier

\begin{listing}[!ht]
\begin{minted}[
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
]{console}
    Representation information for unit Record_Access (body)
--------------------------------------------------------
for Record_String_Int'Object_Size use 192;
for Record_String_Int'Value_Size use 168;
for Record_String_Int'Alignment use 8;
for Record_String_Int use record
   S at  0 range  0 .. 127;
   I at 16 range  0 .. 31;
end record;
\end{minted}
\caption[Memory layout output]{Console output for memory layout}
\label{lst:gnatrj}
\end{listing}
\FloatBarrier

This is the layout of the object in memory:

\begin{figure}[ht!]
    \centering
    \MemoryLayout{
    8/color1bg/Bounds,
    16/color2bg/S,
    20/color3bg/I,
    32/color5bg/padding    
    }
  \caption{Composite type}
  \label{fig:memlayout}
\end{figure}

After modelling it as per previous section, it is then possible to check that the object is correctly represented in Rust by printing its inner representation: 
\inlinecode{AdaRecord \{ data: AdaString \{ inner\_string: 0x23f22a8, bounds: 0x23f22a0 \}, integer: 42 \}}. As we can see, the addresses and bounds come as expected (bounds 8 bytes before) when integer and bool are passed by copy.

\section{Inaccessible memory regions}

In SPARK, we find that when creating access-to-object types to be passed to Rust, those access types must be named and come from the same storage pool. In that case, the object and the access type will share the same area of storage created by the same allocator. \footnote{Storage pool documentation: \url{https://www.adaic.org/resources/add_content/standards/05aarm/html/AA-3-10.html}.}  

When passing objects through \glsxtrshort{FFI}, anonymous access types will be stored in inaccessible memory regions. An automated tool must ensure to use named access types. This is examplified in \Cref{lst:samepool} below.


\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{ada}
package body Ok is
    type String_Access is access String;
  
    function Replace return String_Access is
        -- memory allocated in the same pool
        Hello : String_Access := new String'("hello");

    begin
        -- sending the pointer to Rust
        return Hello;
    end Replace;

package Not_Ok is
    function Replace return access String is
        -- This will give a segmentation fault
        Hello : access String := new String'("hello");

    begin
        return Hello;
    end Replace;
\end{minted}
\caption{Anonymous vs Non-anonymous access types}
\label{lst:samepool}
\end{listing}
\FloatBarrier

\section{Undefined behavior}
\label{sec:undefinied-behavior}
When working with \gls{FFI}, understanding the unique undefined behaviors of each programming language is necessary. 

SPARK has two types of undefined behavior.\footnote{\url{https://learn.adacore.com/courses/SPARK_for_the_MISRA_C_Developer/chapters/07_undefined_behavior.html\#preventing-undefined-behavior-in-spark}.}
In \texttt{unsafe} mode, Rust has no exhaustive list of undefined behavior. Unwinding an error through FFI is one example. Getting data from a raw pointer is another.\footnote{Data must be non-null, aligned, and contained in a single allocated object: \url{https://doc.rust-lang.org/beta/std/slice/fn.from_raw_parts.html\#safety}}
Writing unsafe code comes with a list of invariants that needs to be respected.\footnote{Non-exhaustive list: \url{https://doc.rust-lang.org/reference/behavior-considered-undefined.html}}

In some control studies, errors are deliberately introduced, which sanitizers occasionally rectify. For instance, when reading out of bounds, sanitizers might initialize other memory locations to zero, but this is not always true.

One important aspect to consider is reducing the unsafe segments in the code. Furthermore, it is essential that this code strictly adheres to the invariants for \texttt{unsafe} language to avoid introducing undefined behavior and avoid errors spreading to the rest of the code. In any case, sanitizers are not a solution to this issue as they are not made to catch undefined behavior, which remains the responsibility of the programmer.

In this example, an automated tool should be utilized to check array sizes rigorously, but this is not exhaustive. An automated tool needs to ensure no instances of undefined behavior are overlooked. Interactions with unsafe code are limited to certain operations and should not be used otherwise~\cite{miller_step_2018, noauthor_unsafe_nodate, noauthor_unsafety_nodate}. 
%\todoinline{\href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c9e4d27feaf842c54d9ffc2e5557b1f7}{link to enum stuff}}

\section{Exception and panic management}

Exceptions can be handled in SPARK if the exception is expected, meaning it is covered by a choice in an exception handler. 
Rust has also recoverable errors as \inlinecode{Result<>} and unrecoverable errors in the form of \inlinecode{panic!()}. In the experiments, we saw that exceptions should never unwind across the FFI boundary, as this is undefined behavior. Even if exceptions and panics could theoretically be handled, we recommend the strategy of aborting if exceptions or panic are encountered. 

The reason is that after an error has happened and has been managed, it is impossible to go back to a clean state. Instead, we have a complex interaction with a faulty state and we introduce state extension, when the next state is post-error. We do not know whether this state is fully correct, and there is a risk of branching into a new erroneous state. The best strategy is to crash and recover the system, which implies that some redundancy must be introduced.

\begin{figure}[ht!]
  \centering 
\includesvg[inkscapelatex=false, scale=0.7]{figures/figuressvg/stateextension.svg}
\caption[Faulty state extension]{Faulty state extension: there is no guarantee that the "post-exception" action reverted the system to state 1}
\end{figure}
\FloatBarrier



\section{Passing BBqueue}

The experiment with a complex library is challenging despite the useful guidelines established in the control experiments.

First, we established in \Cref{sec:receiving-fat-pointers}
that all complex structures should be passed by pointer, not reference.
Secondly, the identification and selection of the types proved to be not trivial: BBQueue uses atomic types and statically allocated buffers (for embedded systems).
Thirdly, both types and layouts must match, and it is not the case in both implementations of BBQueue for historical reasons (implementations evolved for different needs).
Nevertheless, the experience gained from control experiments to pass on some information through \gls{FFI} proved useful. This realistic experiment is useful to gain some insights into what information an automated tool needs.

In Rust, BBQueue has two implementations. The official version is not \glsxtrshort{FFI} safe, and an additional version developed for \href{https://github.com/tosc-rs/mnemos/tree/main/source/abi/src/bbqueue_ipc}{mnemos OS} (a custom OS for embedded systems\footnote{\url{https://mnemos.jamesmunns.com/intro.html}}) is used. Another solution would be to expose the internal structure as done with the \texttt{String} in \Cref{sec:receiving-fat-pointers}, but we chose to use a data structure that is designed with FFI in mind. 

As we learned in the control study,  FFI safety is guaranteed by, firstly: \texttt{\#[repr(C)]}, which ensures no mangling and a memory layout consequent with C and prevents the compiler from optimizing. Secondly, the data structure must be modeled on the other side of the FFI barrier.

As seen in \Cref{sec:methodBBQueue}, to keep correctness and safety, the inner buffer must be accessed only through the grants. The header should not be interacted with directly; a pointer to the header is passed in the  \texttt{GrantW} and \texttt{GrantR}. Furthermore, there is a sequence of atomic operations, as the queue is lock-free. This sequence of atomic operations must be executed in the same order for obtaining grants and reading/writing operations.
%\begin{enumerate}
%    \item Get Write Grant
%    \item Commit Write Grant
%    \item Get Read Grant
%    \item Release Read Grant
%\end{enumerate}
   
%This allows all operations to be thread-safe and avoid undefined behavior. The producer and the consumer read the same atomic variables (in the header) and get authorization to touch the actual buffer of \texttt{N} bytes.

Consequently, to use the library in another language successfully, we need to: 
\begin{enumerate}
    \item guarantee consistent layout across the FFI border; 
    \item provide pointers to the grant and the content of the header;
    \item ensure that the header fields are of the right size and are atomic;
    \item ensure the absence of undefined behavior where it can be introduced;
    \item ensure the functions in SPARK interact with the atomic variables in the exact prescribed order --- to guarantee thread safety.
\end{enumerate}


%(the order is carefully designed to prevent consumer or producer from touching parts of data they should not have access to).

There are no differences in the algorithm implementation, but notable differences in the header in both Rust and SPARK, as well as how they should be accessed.
The details can be found in \Cref{ch:additionallistings}, \Cref{lst:rust_bbqueue_header} and \Cref{lst:SPARK_bbqueue_header} respectively.

To respect the design decisions (buffer should be interacted with only through grants as described in \Cref{sec:methodBBQueue}), we modeled the header and read grant on the SPARK side (\Cref{lst:bbqueueheaderinspark} and \Cref{lst:bbqueuereadgrantinspark}). Some variables declared on the Rust side do not exist in the SPARK design, including the pointer to the buffer (due to individual design decisions).
%The reason is that the SPARK implementation passes this information in the Write/Read grant. 
There are also significant differences in the parameters that the functions for atomic operations are taking.

It is possible to reconstruct both the header (\Cref{lst:bbqueueheaderinspark}) and the \texttt{Read} grant (\Cref{lst:bbqueuereadgrantinspark}) in SPARK, after assigning data through a \texttt{Write} grant in Rust, following the recommendations from the control study. The memory layout is as in \Cref{fig:memBBqueue}.


\begin{figure}
    \begin{minipage}{.40\textwidth}
        \begin{bytefield}{24}
        \memsection{..AD0}{..B0F}{4}{Header (64B) - 8 fields of 8 bytes with atomic variables}{color4bg_fill}\tikzmark{end}\\
    	\memsection{..B10}{..B9F}{20}{ BBBuffer       \\ UnsafeCell<[u8; 128]> \tikzmark{end2}\\ (128B+16B padding)}{color4bg_fill}
        \end{bytefield}         \label{fig:hiddenbufferheader}
    \end{minipage}
    \begin{minipage}{.15\textwidth}\quad\quad    \end{minipage}%
    \begin{minipage}{.40\textwidth}
        \begin{bytefield}{6}
        %\begin{rightwordgroup}{Reconstruced \\ Read grant \\ passed to \\ SPARK}
        \memsection{..BA0}{..BA7}{2}{\tikzmark{start} 0x..AD0: pointer to header}{color1bg_fill}\\
        \memsection{..BA8}{..BAF}{2}{\tikzmark{start2} 0x..B10: pointer to BBBuffer}{color1bg_fill}\\
        \memsection{..BB0}{..BB7}{2}{length of read (4)}{color1bg_fill}\\
        %\end{rightwordgroup}
    \end{bytefield}
    \end{minipage}
    \begin{tikzpicture}[overlay,remember picture]
        (pic cs:end);
      \Connect{start}{end}
      \Connect{start2}{end2}
    \end{tikzpicture}
    \caption[BBQueue Read grant in memory]{BBQueue Read grant in memory (not to scale!)\\
    %\legendsquare{fill=green}~Memory allocated in Rust,
    %\textcolor{red}{$\blacksquare$} & Memory allocated in Rust
    \cbox{color4bg_fill} Memory assigned in Rust.\quad \\
    \cbox{color1bg_fill} Memory passed to SPARK.\quad \\
    %\legendsquare{fill=color3bg}~Memory transferred to SPARK
    }
    
    \label{fig:memBBqueue}
\end{figure}


Nevertheless, even if reading from the queue and passing the data structure is possible following the recommendations found from the control studies, the design for the API is not similar enough to use the methods of SPARK on the Rust side of the memory.
One highlight is that by applying the lessons learned from the control study, the final experiment proved to be memory safe when controlled with \texttt{valgrind}.

\section{Summary}

Compared to C, Rust and SPARK offer fine-grained control and rich semantics. But this is accompanied by increased complexity. Rust and SPARK compilers will have expectations that are the responsibility of the programmer. We find that Ada/SPARK is more open to interacting with other languages through \gls{FFI}, while Rust relies more on its internal memory management for its types.
As we shift from controlled studies to a more complex setup, the level of difficulty increases significantly, and the design becomes an important factor that will have an impact on the whole experiment. This highlights the importance of good design and diligent error-checking.


\cleardoublepage

\chapter{Conclusions and Future work}
\label{ch:conclusionsAndFutureWork}

\section{Conclusions}
\label{sec:conclusions}

\subsection{Overview}

This thesis provides safety recommendations for interfacing Rust and SPARK and contributes to research on software safety. As seen in \Cref{ch:background}, Rust and SPARK are both strongly typed and guarantee memory safety, but they rely on different paradigms regarding ownership, and integrating the languages becomes a non-trivial issue. Furthermore, their \glsxtrshort{ABI}s are different, and using \glsxtrshort{FFI} requires the programmer to define the correct data types, respecting the underlying memory layout. This work demonstrates that this interfacing is feasible when respecting specific design rules.

The results confirm the hypothesis that language consistency can be maintained by following rules and respecting invariants that Rust and SPARK compilers expect. The results also confirm the potential of creating an automated tool beyond interfacing through C, while we still rely on the C \glsxtrshort{ABI} for predictability. 

We learned the value of understanding memory management intricacies through control studies and a realistic example by porting BBQueue from Rust to SPARK, and this work opens new questions regarding platform and compiler dependencies, as well as error management. 

While research on unsafe/safe language is abundant, this work has filled a gap in safe bindings between Rust and SPARK, focusing on the concepts of type safety, memory safety, and ownership unique to those languages. We hope the information gathered can take us closer to a future where safety is a core component of systems.

\subsection{Additional considerations}

\Needspace*{6\baselineskip}
Research on memory safety is not trivial, as the information is abundant and scattered (language and compiler documentation, expert knowledge, reference books, and issues discussed on GitHub). Rust and SPARK/Ada are rich languages, the issues deal with language specifics and even compiler-specific quirks. However, the positive outcome is that it is feasible to move beyond \gls{FFI} written in C and create an automated tool that would bind safely richer languages. that ensured predictability. 

Getting a deeper understanding of memory management was a personal milestone, and this can also be considered as successful.

If we were to do this work again, it would have been potentially very valuable to look into similar tools (bindgen~\cite{noauthor_bindgen_2022}) and formal proof tools before creating manual bindings. Formally proving those bindings correct would have been of great added value.

\section{Limitations}
\label{sec:limitations}

Several limiting factors affected our efforts and the scope of the results.

Time constraints were a significant limitation. These restricted our ability to port all interesting data structures, particularly deeply recursive types, even if we ported nested data structures. Unfortunately, the bi-directional port of BBQueue from SPARK to Rust remains unfulfilled. In addition, a comprehensive redesign of BBQueue in either Rust or SPARK would have been necessary to carry the experiment in both directions. This redesign is out of the scope of our study, but this is still unfortunate. 

Valuable tools for formal verification exist (\texttt{KANI}, \texttt{Miri}, and \texttt{GNATprove}). However, those tools are not designed for FFI applications and time limitations did not allow us to delve into these resources and see how we could (possibly) adapt them for our experiments.

Limited experience with Ada and SPARK also restricted the project's progress, as learning the languages ran concurrently with the thesis writing. More time dedicated to focusing on SPARK specifics could have been beneficial.

Similarly, studying undefined behavior for Rust and SPARK would have been helpful for this exploration.

\section{Future work}
\label{sec:futureWork}

While progress was made during this project, unfulfilled objectives and opportunities for future research remain. Those unfulfilled objectives arose following various technical difficulties, the learning process, and emerging questions. 
The primary sub-goal that is not completed is the bi-directional porting of BBQueue. The port was made from Rust to SPARK, but not vice versa. There are indications that the port from SPARK to Rust would be as challenging and time-consuming, but its completion would bring valuable insights.

A promising avenue for future efforts involves studying the implementation of bindgen~\cite{noauthor_bindgen_2022} and other automated tools from and to C, and what can be transferable for a Rust/SPARK binding tool.

A redesign of BBQueue also merits consideration to facilitate a more consistent experimental approach; significant differences hindered the current project in design.

Despite the inherent safety offered by the languages, a thorough and robust testing framework is necessary. This could be a valuable addition to a future project examining FFI.

Platform dependency emerged as a challenging aspect of the project, opening an entirely new area for research. 

Finally, proper error management is a complex area that requires dedicated attention -- Rust has a very sophisticated error management system, and SPARK has specific rules for exceptions. Future work could address this field more comprehensively.

As a conclusion, in a time when memory safety is promoted in several fields, this is a step forward in combining safer languages than C and C++.



\noindent\rule{\textwidth}{0.4mm}
%\engExpl{In the references, let Zotero or other tool fill this in for you. I suggest an extended version of the IEEE style, to include URLs, DOIs, ISBNs, etc., to make it easier for your reader to find them. This  make life easier for your opponents and examiner. \\IEEE Editorial Style Manual: \url{https://www.ieee.org/content/dam/ieee-org/ieee/web/org/conferences/style_references_manual.pdf}}
%\sweExpl{Låt Zotero eller annat verktyg fylla i det här för dig. Jag föreslår en utökad version av IEEE stil - att inkludera webbadresser, DOI, ISBN osv. - för att göra det lättare för läsaren att hitta dem. Detta kommer att göra livet lättare för dina opponenter och examinator.}

\cleardoublepage
% Print the bibliography (and make it appear in the table of contents)
\renewcommand{\bibname}{References}
\addcontentsline{toc}{chapter}{References}

\ifbiblatex
    %\typeout{Biblatex current language is \currentlang}
    \printbibliography[heading=bibintoc]
\else
    \bibliography{references}
\fi



% \warningExpl{If you do not have an appendix, do not include the \textbackslash cleardoublepage command below; otherwise, the last page number in the metadata  be one too large.}
\cleardoublepage
\appendix
\renewcommand{\chaptermark}[1]{\markboth{Appendix \thechapter\relax:\thinspace\relax#1}{}}

\chapter{Rust project crates information}
\label{ch:cratesinfo}

This chapter provides detailed information on 13 popular Rust projects.

\section{Tables}
\begin{table}[ht!]
\footnotesize
\centering
\caption[Most popular projects on crates.io]{Most popular projects on crates.io (\num{171897} LOC)}
\label{tab:crates_io}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ |l|>{\raggedright}p{4cm}|>{\raggedright}p{3cm}|>{\centering\arraybackslash}p{1.8cm}|S[table-format=7.0]| }
\hline
\rowcolor{color1bg_fill}
\textbf{Package}& \textbf{Description} & \begin{tabular}{@{}l} \textbf{Git hash} \\ (\textbf{Reverse} \\ \textbf{Dependencies})\end{tabular}&\textbf{Downloads} \newline \textbf{(millions)} & \textbf{LOC}\\
\hline
libc & Raw FFI bindings to platform libraries like libc & \#89ec881 (\num{5200}) & 177 & \num{100719}\\
\hline
syn & Parser for Rust source code & \#6365093 (\num{5501}) & 191 & \num{50801} \\
\hline
rand \& rand-core & Random number generators and other randomness functionality & \#0f3eced (\num{9892}) & 183 & \num{13655}\\
\hline
quote & Macro for turning Rust syntax tree data structures into tokens of source code & \#ca98b65 (\num{5498}) & 177 & \num{2154}\\
\hline
cfg-if & Ergonomically defines an item depending on a large number of \#[cfg] & \#2621a59 (\num{1147}) & 175 & \num{144} \\
\hline
procmacro2 & A substitute implementation of the compiler's proc\_macro API & \#ab25487 (\num{4538}) & 176 & \num{4424}\\
\hline
\end{tabular}
\end{table}
\FloatBarrier

\begin{table}[ht!]
\footnotesize
\centering
\caption[Most popular projects on lib.rs]{Most popular projects on lib.rs (172,059 LOC)}
\label{tab:lib_rs}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ |l|>{\raggedright}p{4cm}|>{\raggedright}p{3cm}|>{\centering\arraybackslash}p{1.8cm}| S[table-format=7.0]| }
\hline
\rowcolor{color1bg_fill}
\textbf{Package}& \textbf{Description} & \textbf{Git hash} \newline \textbf{(Reverse Dependencies)}&\textbf{Downloads} \newline \textbf{all time in millions} & \textbf{LOC}\\
\hline
serde & Framework for serializing and deserializing & \#b80e722 (\num{26571}) & \num{151} & \num{30681} \\
\hline
serde-json & A JSON serialization file format & \#a15bd09 (\num{17799}) & \num{126} & \num{15553} \\
\hline
clap & Command line args parser & \#8469554 (\num{10933}) & \num{106} & \num{49799} \\
\hline
log & A lightweight logging facade for Rust & \#dc32ab9 (\num{12709}) & \num{135} & \num{3322} \\
\hline
thiserror & Error handler & \#0e45dde (\num{9779}) & \num{83} & \num{2812} \\
\hline
tokio & Non-blocking platform for asynchronous I/O backed applications & \#1df874e (\num{12745}) & \num{89} & \num{69892} \\
\hline
\end{tabular}
\end{table}
\FloatBarrier
\clearpage
\section{Detailed counting}

\pgfplotstableread{
Rust_type crates_io lib_rs rustc
Numbers  44715 22470 305087
Refs 12662 13909 137530
Arrays  329 700 13790
Vec  228 1682 8576
Enum  602 1283 15040
Struct  4704 3646 48955
String  445 1363 18613
}\EXPDATA 

\begin{figure}[!h]
    \centering
    %\scalebox{0.9}{
    \begin{tikzpicture}
        \begin{axis}[ 
            cycle list name=rustcolors,
            xtick=data,
            symbolic x coords={Numbers,Struct,String,Refs, Arrays,Vec,Enum},
            ybar,
            ymajorgrids=true,
            grid style=dashed,
            ymode=log,
            tick label style={
                /pgf/number format/sci,
                /pgf/number format/sci zerofill,
                /pgf/number format/precision=1
            },
            log plot exponent style/.style={
                /pgf/number format/fixed,
                %/pgf/number format/use comma,
                /pgf/number format/precision=0},
            width=1\textwidth,
            ylabel=Count of types,
            reverse legend=true,
            width=1\textwidth,
            reverse legend=false,
            legend style={draw=none},
            legend image post style={scale=2.0},
            legend style={
                at={(0.5,-0.1)},
            anchor=north,
            %legend columns=-2
            %mark size=20pt,
        },
            ]
          \addplot table [x=Rust_type, y=rustc]{\EXPDATA} ;
          \addplot table [x=Rust_type, y=crates_io]{\EXPDATA} ;
          \addplot table [x=Rust_type, y=lib_rs]{\EXPDATA} ;
        \legend{rustc (1518 kLOC), crates.io (171 kLOC), lib.rs (172 kLOC)}
        \end{axis}  
    \end{tikzpicture}
    %}
\caption{Absolute number of Rust data types per project}
\label{fig:barplottypesrust}
\end{figure}
%https://tex.stackexchange.com/questions/188147/how-to-put-legend-below-the-chart
\clearpage


\cleardoublepage
\chapter{Regexes}
\label{sec:regexes}

This section covers Rust and SPARK regexes.
\section{Rust regexes}

The Rust regex patterns are designed to match type declarations and literals, except for the number pattern. The number pattern focuses on matching numeric literals. Since the Rust compiler is generally efficient at deducing the types, writing a type declaration is generally omitted. The patterns cover the following constructs:

\begin{enumerate}
    \item Numbers (\verb|\b(?:\d+(?:\.\d\+)?\d+(?:\_\d\+)\+)\b|): 
    
    Matches integer and floating-point literals, including those with underscores. For example:
    \begin{minted}[fontsize=\footnotesize]{rust}
    let c = 3.14;
    \end{minted}
    \item Enums and Structs (\verb|struct| and \verb|enum|): both \texttt{struct}s and \texttt{enum}s are declared with a keyword. 
    \begin{minted}[fontsize=\footnotesize]{rust}
    struct Point {
        x: f32,
        y: f32,
    }
    enum Color {
        //...
    }
    \end{minted}
    \end{enumerate}
    \clearpage
    \begin{enumerate}[resume]
    \item Arrays (\verb|\[(\s*\d+\s*(?:,\s*\d+\s*)*)\]|):
    
    Matches array literals, excluding array declarations to avoid double matching and overreporting the type. For example, this will be only one match:
    \begin{minted}[fontsize=\footnotesize]{rust}
    let a : [i32; 5] = [1, 2, 3, 4, 5];  
    \end{minted}
    \item References (\verb|&[mut\s]*\w+|): Matches mutable and immutable reference types. It will match \texttt{\&T} and \texttt{\&mut T}.
    \begin{minted}[fontsize=\footnotesize]{rust}
    let y = &mut x;  
    \end{minted}
    \item Heap Types (\verb|Box<[<>]+>| \verb|Rc<[<>]+>|\verb|Arc<[<>]+>|): Matches Box, Rc, and Arc heap-allocated type declarations. For example:
    \begin{minted}[fontsize=\footnotesize]{rust}
    let boxed_value: Box<i32>
    \end{minted}
    \item Dynamic Vectors (\verb|vec!|Vec::new|): 
    
    Matches dynamic vector types declaration in Rust and the vec![] macro.
    \begin{minted}[fontsize=\footnotesize]{rust}
    let v = Vec::new();
    \end{minted}
    \item Strings (\verb|String::|.to\_string|format!|): 
    Matches String creation and manipulation through various methods and macros.
    \begin{minted}[fontsize=\footnotesize]{rust}
    let girl_name = "Mouneissa".to_string();
    \end{minted}
\end{enumerate}
 
\section{SPARK regexes}

These focus on type declarations.
The patterns cover the following constructs:

\begin{enumerate}
    \item Numbers 
(\verb|: Integer ||| \verb|range \d.. \d| || \verb|is digits|).

This pattern uses Ada keywords for numbers (\texttt{Integer, Float, Modular...}) and matches various numeric types such as integer, float, fixed, decimal, modular, natural, positive, long, and range, but not an array declaration where the type is used for indexing or as the type contained in the array. We choose to proceed differently and list all possible types as SPARK requires initialization. It matches predefined types and custom declarations but not when array of numbers are declared

    \begin{minted}[fontsize=\footnotesize]{ada}
    -- matches:
    X : Integer := 42;
    Y : Short_Integer := 5;
    type My_Integer is range -100 .. 100;
    -- does not match:
    type Integer_Array is array (1 .. 5) of Integer;
    \end{minted}

    \item Structs (\verb|type\s\+\w\+\s\+is\s\+record|). This pattern matches record types, which are similar to structs in other languages.

    \begin{minted}[fontsize=\footnotesize]{ada}
    type Point is record
        -- ...
    end record;
    \end{minted}

    \item Enums: (\verb|type\s\+\w\+\s\+is\s\+\(|). Matches enumeration types in SPARK.

    \begin{minted}[fontsize=\footnotesize]{ada}
    type Color is (Red,Orange,Green);
    \end{minted}

    \item Arrays: (\verb|type\s+[a-zA-Z\_]+\s+is\s+array\s*(\d+)|). Matches array declarations.

    \begin{minted}[fontsize=\footnotesize]{ada}
    type Int_Array is array (1 .. 10) of Integer;
    \end{minted}

    \item Dynamic Vectors: (Combines \verb|range <>|, \verb|Containers.Vector| and \verb|Containers|).
This pattern matches unconstrained arrays and instances of the Containers.Vector package.

    \begin{minted}[fontsize=\footnotesize]{ada}
    type Int_Vector is array (Integer range <>) of Integer;
    \end{minted}

    \item References: (Combines: \verb|type\s+\w+\s+is\s+access\s+\w+| and \verb|new\s+\w+)|). This pattern matches access types (pointers) and memory allocations using 'new'.

    \begin{minted}[fontsize=\footnotesize]{ada}
    type Int_Ptr is access Integer;
    \end{minted}

    \item Unbounded Strings: (\verb|Strings.Unbounded|). This matches unbounded strings from the Ada.Strings.Unbounded package.

    \begin{minted}[fontsize=\footnotesize]{ada}
    S : Unbounded_String;
    begin
    S := "Some string";
    \end{minted}
\end{enumerate}

 

\chapter{Separation of concerns}
\label{ch:separation_of_concerns}

This control study can be found in the repository under the name \texttt{ada\_string\_overwriter}. It is an experiment from Rust to SPARK. It demonstrates type safety, memory safety and effective management of ownership in an idiomatic manner. The Rust struct AdaString provides an API that abstracts the details of the FFI. 

Key points:

\begin{enumerate}
    \item Unsafe Code is isolated. The Rust code uses a smart-pointer-like struct AdaString to encapsulate the unsafe parts inside the type definition. The API presented to to the user is safe.
    \item The memory allocation and deallocation are called by Rust (allocate\_str, drop called) but handled by SPARK Ada: each language manages its own memory. We know different language have different memory management strategies (such as storage pools), and solving memory bugs linked to memory allocation is not trivial.
   
\end{enumerate}
    
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{rust}
use std::ops::{Deref, DerefMut};
use std::os::raw::c_char;
use std::slice;
#[derive(Debug)]
#[repr(C)]
// As per the documents, the right type is i32.
// Using i8 will cause layout problems.
struct AdaBounds {
    first: i32,
    last: i32,
}

// `Copy` is not allowed on types with destructors
// This additional wrapper is necessary.
#[derive(Copy, Clone, Debug)]
#[repr(C)]
struct AdaStringPtr {
    data: *mut u8,
    bounds: *const AdaBounds,
}

// This stays in the rust world (no FFI-ed)
// It has implements a destructor, that will be called
// on the internal pointer.
struct AdaString {
    ptr: AdaStringPtr,
}

// The unsafe code is moved inside the type definition.
impl AdaString {
    fn new() -> Self {
        let ptr = unsafe { allocate_str() };
        Self { ptr }
    }

    // Obs! c_char is platform dependent
    // Different impls come here (as_mut, as_ref)

    fn len(&self) -> usize {
        unsafe {
            ((*self.ptr.bounds).last - (*self.ptr.bounds).first)
                .try_into()
                .unwrap()
        }
    }
}

// Drop is expected by Rust but 
// the behavior itself is implemented in SPARK
impl Drop for AdaString {
    fn drop(&mut self) {
        unsafe {
            free_str(self.ptr);
        }
    }
}

// impl Deref and DerefMut for AdaString come here ...

// SPARK functions
extern "C" {
    fn allocate_str() -> AdaStringPtr;
    fn free_str(ptr: AdaStringPtr);
}
fn main() {
    let mut ada_str = AdaString::new();

    // Unsafety is now isolated inside the type definition 
    // and we can rely on the Rust usual behavior
    ada_str[0] = b'W' as c_char;

    drop(ada_str);

    println!("The pointer was just dropped in Rust.");
}
\end{minted}


\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{ada}
package Overwriter is
  --type Constrained_string is new String (1 .. 5);
  type String_access is access all String;
  function Allocate_str return String_access with
   Export, External_Name => "allocate_str";
  procedure Free_str (S : String_access) with
   Export, External_Name => "free_str";
end Overwriter;


pragma Ada_2022;
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Unchecked_Deallocation;

package body Overwriter is

    Hello : String_access;

    function Allocate_Str return String_access is
    begin

    Hello := new String'("hello");
    Put_Line ("Address of Hello in SPARK: " & Hello'Img);
        return Hello;
    end Allocate_Str;

    -- unchecked deallocation expects a parameter it can changes,
    -- that's the reason for "in out" here, in addition to the
    -- named access type.
    procedure Free_str (S : in out String_access) is
        procedure internal_free is new Ada.Unchecked_Deallocation
           (Object => String, Name => String_access);
    begin
        Put_Line ("Returned string SPARK S.all: " & S.all);
        Put_Line ("Returned string SPARK S'Img: " & S'Img);
        internal_free (S);
    end Free_str;

end Overwriter;

\end{minted}
\chapter{Additional listings}
\label{ch:additionallistings}

\section{BBQueue headers}
\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{rust}
#[repr(C)]
pub struct BBBuffer {
    buf: AtomicPtr<u8>,
    buf_len: AtomicUsize,
    write: AtomicUsize,
    read: AtomicUsize,
    last: AtomicUsize,
    reserve: AtomicUsize,
    read_in_progress: AtomicBool,
    write_in_progress: AtomicBool,
}
\end{minted}
\caption[BBQueue header in Rust]{BBQueue header in Rust}
\label{lst:rust_bbqueue_header}
\end{listing}
\FloatBarrier

\begin{listing}[!ht]
\begin{minted}[fontsize=\footnotesize]{ada}
 type Offsets_Only (Size : Buffer_Size) is limited record
      Write : aliased Atomic_Count.Instance 
      := Atomic_Count.Init (0);
      Read  : aliased Atomic_Count.Instance 
      := Atomic_Count.Init (0);
      Last  : aliased Atomic_Count.Instance 
      := Atomic_Count.Init (0);
      Reserve  : aliased Atomic_Count.Instance 
      := Atomic_Count.Init (0);
      Read_In_Progress : aliased Atomic.Flag 
      := Atomic.Init (False);
      Write_In_Progress : aliased Atomic.Flag 
      := Atomic.Init (False);
      Granted_Write_Size : Count := 0;
      Granted_Read_Size : Count := 0;
   end record
     with Invariant =>
    -- series of invariants
   ;
\end{minted}
\caption[BBQueue header in SPARK]{BBQueue header in SPARK}
\label{lst:SPARK_bbqueue_header}
\end{listing}
\FloatBarrier

\section{Reconstructed BBQueue header and Read grant}
\begin{listing}[ht!]
\begin{minted}[framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize]{ada}
type BBBuffer is record
    Buf : System.Address; -- not needed
    Inner_buf         : System.Address; -- not needed
    Write             : Interfaces.Unsigned_64;
    Read              : Interfaces.Unsigned_64;
    Last              : Interfaces.Unsigned_64;
    Reserve           : Interfaces.Unsigned_64;
    Read_In_Progress  : Boolean;
    Write_In_Progress : Boolean;
    --Granted_Write_Size : Count := 0; missing!
    --Granted_Read_Size : Count := 0; missing!
    end record;
\end{minted}
\caption{Modelling the header}
\label{lst:bbqueueheaderinspark}
\end{listing}
\FloatBarrier


\begin{listing}[ht!]
\begin{minted}[framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize]{ada}
type RustReadGrant is record
    bbq: System.Address;
    inner_buf: System.Address;
    buf_len: Interfaces.Unsigned_64;
end record;
-- Reminding the compiler the object must be passed by reference
pragma Convention (Ada_Pass_By_Reference, RustReadGrant);
\end{minted}
\caption{Modelling the Read Grant}
\label{lst:bbqueuereadgrantinspark}
\end{listing}
\FloatBarrier
\cleardoublepage


\chapter[Build systems to reproduce experiments]{Build systems to reproduce\linebreak[4] experiments}
\label{sec:buildSystems}


\section{System}
\begin{quote}
Linux 5.19.0-051900-generic \#202207312230 SMP\linebreak[4] PREEMPT\_DYNAMIC Sun Jul 31 22:34:11 UTC 2022 x86\_64 GNU/Linux

Description: Ubuntu 22.04.1 LTS

Release:	22.04
\end{quote}

% the following sets the TOC entry to break after the & - note you have to include the first letter of the following word as it get swolled by the \texorpdfstring{}{} processing
%\section[Environment for \& SPARK/Rust experiments]{Environment for SPARK/Rust experiments}

%For reproducibility purposes,  \Cref{sec:buildSystems} describes the setup from a high-level perspective while the source code is available in \Cref{sec:systemDocumentation}.


\section{Build systems SPARK to Rust}

\Cref{fig:sparkbuild} shows the build process for a SPARK file using a Rust library. The process is straightforward: all files are in the same folder, and a script runs the build. The script can be adjusted to include useful switches\footnote{\url{https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/building_executable_programs_with_gnat.html}} as described for example in \Cref{sec:compositetypes}. 
Both files reside in the same root folder and this is a straightforward process. 
The SPARK file is compiled without optimizations for debugging purposes and the Rust library is compiled as a static library for simplicity. 
Gnatbind then checks whether the SPARK program is consistent and the linking with the Rust library is done in the last step.
The process is designed to fail if a step does not compile properly and provides useful information for debugging.

\begin{figure*}[ht!]
    \centering
    \begin{tikzpicture}[node distance=2cm, font=\small]
    \tikzstyle{process} = [draw, rectangle, minimum width=5cm, minimum height=1.5cm, text centered, text width=6cm, fill=white, rounded corners=10,thick, inner sep=5pt]
    \tikzstyle{smallprocess} = [draw, rectangle, minimum width=2.5cm, minimum height=1cm, text centered, text width=2.2cm, fill=white, rounded corners=5,thick]
    \tikzstyle{arrow} = [->, >=stealth, thick]
    \node (step1) [process, fill=color1bg_fill] {Common root folder 
    \begin{tikzpicture}[font=\footnotesize, scale=0.2, inner sep=10pt]
    \node (main) [smallprocess, fill=color2bg_fill] {main.adb};
    \node (lib) [smallprocess, fill=color2bg_fill, right of=main, xshift=1cm] {lib.rs};
    \end{tikzpicture}
    };
    \node (step2) [process, below of=step1,fill=color3bg_fill] {Compile SPARK main};
    \node (step3) [process, ,fill=orange!20, below of=step2] {Compile Rust lib as static lib};
    \node (step4) [process, fill=color4bg_fill, below of=step3] {Control consistency};
    \node (step5) [process, fill=color5bg_fill, below of=step4] {Link Ada and Rust objects};
    \draw [arrow] (step1) -- (step2) node[midway, right] {gcc -O0};
    \draw [arrow] (step2) -- (step3) node[midway, right] {rustc staticlib};
    \draw [arrow] (step3) -- (step4) node[midway, right] {gnatbind};
    \draw [arrow] (step4) -- (step5) node[midway, right] {gnatlink SPARK, Rust and system libs};
\end{tikzpicture}
\caption{Process for SPARK code using Rust library}
\label{fig:sparkbuild}
\end{figure*}
\FloatBarrier

\section{Build systems Rust to SPARK}

\Cref{fig:rustbuild} shows the build process for a Rust project using a SPARK project. 

The main difference is using the crate \texttt{gpr, v0.1.2}\footnote{\url{https://crates.io/crates/gpr}}, designed for more complex projects~\cite{kliemann_adding_2022}. While it introduces more complexity for control studies, it also allows access to a richer toolset (package managers alire and cargo for Ada and Rust respectively), which is useful to set up more complicated experiments and is used in the BBQueue experiment.  

An entire Rust project is built with \texttt{cargo new <proj>}, the Rust packet manager. Then a library project is built inside the Rust project with \texttt{alire}, the GNAT packet manager \texttt{alr init --lib <newlib>}. The library path is provided to the Rust \texttt{build.rs} file. This approach requires some familiarity with Rust and Ada packet managers.
Even in this case, we made the build fail if one step is not successful, to avoid to inadvertently run an experiment with an old version of the library.

\begin{figure*}[ht!]
\centering
    \begin{tikzpicture}[node distance=2.8cm, font=\small]
    \tikzstyle{process} = [draw, rectangle, minimum width=6cm, minimum height=1.5cm, text centered, text width=5.5cm, fill=white, rounded corners=10,thick]
    \tikzstyle{smallprocess} = [draw, rectangle, minimum width=3.5cm, minimum height=0.8cm, text centered, text width=3.2cm, fill=white, rounded corners=5,thick]
    \tikzstyle{arrow} = [->, >=stealth, thick]
        \node (step1) [process, fill=color1bg_fill] {Cargo project \
        \begin{tikzpicture}[font=\footnotesize, scale=0.2, inner sep=2pt]
        \node (lib.adb) [smallprocess, fill=color2bg_fill] {lib.adb};
        \end{tikzpicture}
        };
        \node (step2) [process, below of=step1,fill=color3bg_fill] {Load SPARK project file with gpr crate};
        \node (step3) [process, ,fill=color4bg_dark_fill, below of=step2] {Build SPARK project with gprbuild command};
        \node (step4) [process, fill=color4bg_fill, below of=step3] {Generate linker search path and flags for Cargo};
        \node (step5) [process, fill=color5bg_fill, below of=step4] {Build and link Rust executable};
        \draw [arrow] (step1) -- (step2) node[midway, right] {cargo run + path to LD\_LIBRARY\_PATH};
        \draw [arrow] (step2) -- (step3) node[midway, right] {Call gprbuild};
        \draw [arrow] (step3) -- (step4) node[midway, right, align=center] {Extract library directory \\ and name from project object};
        \draw [arrow] (step4) -- (step5) node[midway, right,  align=center] {Use linker search path and flags \\ to build and link executable};
    \end{tikzpicture}
\caption{Process for Rust code building a SPARK library}
\label{fig:rustbuild}
\end{figure*}
\FloatBarrier
% \textcolor{black}{black} {\color{black} \rule{\linewidth}{1mm} }

% Include an example of using nomenclature
% \ifnomenclature
% \cleardoublepage
% \chapter{Main equations}
% \label{ch:NomenclatureExamples}
% This appendix gives some examples of equations that are used throughout this thesis.
% \section{A simple example}
% The following example is adapted from Figure 1 of the documentation for the package nomencl (\url{https://ctan.org% /pkg/nomencl}).
% \begin{equation}\label{eq:mainEq}
% a=\frac{N}{A}
% \end{equation}
% \nomenclature{$a$}{The number of angels per unit area\nomrefeq}%       %% include the equation number in the list
% \nomenclature{$N$}{The number of angels per needle point\nomrefpage}%  %% include the page number in the list
% \nomenclature{$A$}{The area of the needle point}%
% The equation $\sigma = m a$%
% \nomenclature{$\sigma$}{The total mass of angels per unit area\nomrefeqpage}%
% \nomenclature{$m$}{The mass of one angel}
% follows easily from \Cref{eq:mainEq}.

% \section{An even simpler example}
% The formula for the diameter of a circle is shown in \Cref{eq:secondEq} area of a circle in \cref{eq:thirdEq}.
% \begin{equation}\label{eq:secondEq}
% D_{circle}=2\pi r
% \end{equation}
% \nomenclature{$D_{circle}$}{The diameter of a circle\nomrefeqpage}%
% \nomenclature{$r$}{The radius of a circle\nomrefeqpage}%

% \begin{equation}\label{eq:thirdEq}
% A_{circle}=\pi r^2
% \end{equation}
% \nomenclature{$A_{circle}$}{The area of a circle\nomrefeqpage}%

% Some more text that refers to \eqref{eq:thirdEq}.
% \fi  %% end of nomenclature example

%\cleardoublepage
% Information for authors
%\include{README_author}
% \subfile{README_author}

% \cleardoublepage
% information about the template for everyone
% \input{README_notes/README_notes}


% information for examiners
% \ifxeorlua
% \cleardoublepage
% \input{README_notes/README_examiner_notes}
% \fi

% Information for administrators
% \ifxeorlua
% \cleardoublepage
% \input{README_notes/README_for_administrators.tex}
% \fi



% Information for Course coordinators
% \ifxeorlua
% \cleardoublepage
% \input{README_notes/README_for_course_coordinators}
% \fi


%% The following label is necessary for computing the last page number of the body of the report to include in the "For DIVA" information
\label{pg:lastPageofMainmatter}

\cleardoublepage
\clearpage\thispagestyle{empty}\mbox{} % empty page with backcover on the other side
\kthbackcover
\fancyhead{}  % Do not use header on this extra page or pages
\section*{€€€€ For DIVA €€€€}
\lstset{numbers=none} %% remove any list line numbering
\divainfo{pg:lastPageofPreface}{pg:lastPageofMainmatter}


\end{document}
